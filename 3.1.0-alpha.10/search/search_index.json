{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TA.Utilities Overview","text":"<p>This library represents a collection of classes factored out of our production projects that we found were being used over and over again. Rather than re\u2011using the code at source level, it is collected together in this package as a general\u2011purpose reusable library and made freely available for you to use at no cost and with no obligation. The only stipulation is that you cannot sue the author or Timtek Systems Limited if anything bad happens as a result of you using the code. It is up to you to determine suitability for your purpose.</p>"},{"location":"#software-reuse-at-the-object-code-level","title":"Software re\u2011use at the object code level","text":"<p>This was always the promise of object\u2011oriented design, but it was not until the advent of NuGet and its widespread adoption that this became a practical reality. It is easy to overlook the impact of NuGet, as it seems so obvious and natural once you have used it.</p> <p>\"Dependency management is the key challenge in software at every scale.\" \u2014 possibly attributed to Donald Knuth, The Art of Computer Programming</p> <p>NuGet has essentially solved a large chunk of the dependency management problem. At Timtek Systems, we use NuGet as a key component in our software design strategy. We publish our open\u2011source code on a public MyGet feed. We push both prerelease and release versions to MyGet. When we make an official release, we promote that package from MyGet to NuGet. You can consume our packages from either location, but if you want betas and release candidates, you will need to use our MyGet feed.</p>"},{"location":"#licensing","title":"Licensing","text":"<p>This software is released under the Tigra MIT Licence, which (in summary) means: \"Anyone can do anything at all with this software without limitation, but it is not our fault if anything goes wrong\".</p> <p>Our philosophy of open source is to give wholeheartedly with no strings attached. We have no time for \u201ccopyleft\u201d licences which we find irksome. So here it is, for you to use however you like, no strings attached.</p> <p>I tend to use \u201cwe\u201d and \u201cour\u201d when talking about the company, but Timtek Systems Limited is a one\u2011man operation run by me, Tim Long. I hope you find the software useful, and if you feel that my efforts are worth supporting, then it would make my day if you would buy me some coffee. I also would not mind you giving us a mention, if you feel you are able to, as it helps the company grow. Donations and mentions really make a difference, so please think about it and do what you can.</p> <p>If you are a company and need some work done, then consider hiring me as a freelance developer. I have decades of experience in product design, firmware development for embedded systems and PC driver and software development. I am a professional; I believe in doing what is right, not what is expedient, and I support my software.</p>"},{"location":"About%20GitVersion/","title":"GitVersion: benefits over manual versioning","text":"<p>GitVersion automates semantic versioning by deriving a version from your Git history and branch conventions. Compared to hand\u2011maintained versions, it provides consistency, removes busywork, and eliminates whole classes of release mistakes.</p> <p>Key benefits - Zero manual bumps   - No more \u201cremember to bump\u201d PRs; the version is computed from commits/branches/tags. - Consistent SemVer across all builds   - CI, local dev, and release builds resolve the same version for the same commit. - First\u2011class pre\u2011releases without ad\u2011hoc suffixes   - Branches map to pre\u2011release channels (e.g., develop \u2192 alpha, release/* \u2192 beta) with incremental identifiers. - Traceability and provenance   - InformationalVersion embeds branch and commit (e.g., +Branch.develop.Sha.XXXX), making binaries self\u2011describing. - Works with Git Flow   - Feature \u2192 pre\u2011release while developing; release branches stabilize as beta; tagging on main/master promotes to a stable version. - Deterministic packages and assemblies   - Packages built from the same commit get the same version, avoiding \u201cmystery rebuilds\u201d that overwrite artifacts. - Cleaner PRs and histories   - No noise commits solely to bump versions; reduces merge conflicts in project files. - Policy as configuration   - Version rules live in configuration rather than tribal knowledge; easy to review and change as a team policy.</p> <p>How it helps in this repository - We already reference GitVersion.MsBuild in the packable libraries, so assemblies and NuGet packages receive the computed version automatically at build time. - The docs site deployments also use the GitVersion SemVer as the mike version for develop and release/* builds, so your published documentation versions align with your code versions. - Release tagging uses the raw semantic tag (no leading \u201cv\u201d), which becomes the published stable version and moves the latest alias in documentation.</p> <p>Manual versioning pitfalls avoided - Forgotten or inconsistent bumps between projects/solutions in a repo. - Conflicting edits to the same version fields during parallel work/merges. - Drift between \u201cAbout\u201d dialogs, assembly attributes, package versions, and documentation. - Ambiguous nightly/CI builds where two different commits share the same nominal version.</p> <p>See also - Versioning (GitVersion + SemVer)</p>"},{"location":"Diagnostics%20and%20Logging/","title":"Diagnostics and Logging","text":""},{"location":"Diagnostics%20and%20Logging/#consoleloggerservice-implements-ilog","title":"<code>ConsoleLoggerService</code> implements <code>ILog</code>","text":"<p>One step up from the <code>DegenerateLoggerService</code>, enables easy rudimentatary logging to the console without depending on any logging framework or configurations files. This is meant to be a light-weight stop-gap logging solution for projects that never get large enough to warrant full structured logging.</p> <p><code>ConsoleLoggerService</code> is fully compatible with and interchangeable with any logging back-end built on the <code>ILog</code> interface. The Liskov Subsitution Principle is observed, so it remains easy to switch logging back-ends just by changing a binding in your IOC container. Start yoru console app with a <code>ConsoleLoggingService</code>, then when it becomes a limitation, simply plug-in a full-blown logger such as the NLog implementation founf in <code>TA.Utils.Logging.NLog</code>.</p>"},{"location":"Diagnostics%20and%20Logging/#logging","title":"Logging","text":"<p>Logging is a big deal. It is an essential part of debugging during development, but can also be really useful or even essential in production. It needs to be easy to use, or developer's won't use it. It needs to not re-invent any wheels. There are plenty of good logging services out there.</p> <p>Our approach to logging is this: 1. No dependency on any particular logging framework.    We define an abstract interface that can be adapted to any back-end logging engine. 2. Follow the KISS principle: \"Keep it simple, stupid\".    Logging should be easy enough that people will use it, but have enough flexibility to be useful in the real world.</p> <p>We provide an abstract fluent builder pattern for easily constructing log entries and which provides an extensibility point for creating extension methods.</p> <p>Our fluent builder interface supports semantic logging which enables the creation of rich logging data.</p> <p>Item (1) notwithstanding, we have based our fluent builder API loosely on the one used by NLog. We think it is the best balance of simplicity and flexibility. However, we do not depend on NLog and have made our own abstract interfaces that can target any logging framework.</p> <p>The <code>TA.Utils.Core.Diagnostics</code> namespace defines a pair of interfaces, <code>ILog</code> and <code>IFluentLogBuilder</code>, that define an abstract logging service which does not depend on any particular back-end.</p> <p>Libraries can perform logging through these interfaces without ever taking a dependency on any logging imnplementation. The actual implementation can be injected at runtime, typically in a constructor parameter. The policy decision about which logging engine to use can be taken in the top level composition root of the application.</p> <p>The fluent interface defined in <code>IFluentLogBuilder</code> was modeled on the NLog fluent interface, so it is a very natural fit. However, the interface has enough flexibility to adapt to other logging backends without too much trouble.]</p> <p>A null implementation is provided in <code>DegenerateLoggerService</code> and <code>DegenerateLogBuilder</code>. The two classes do essentially nothing and produce no output; they are a data sink. Libraries can choose to use this as their default logging implementation, which is easier than checking whether the logger is null every time it is used.</p> <pre><code>public class MyClassThatUsesLogging\n{\n    private ILog Log;\n\n    // Construct an instance and optionally inject the logging service implementation.\n    public MyClassThatUsesLogging(ILog logService = null)\n    {\n        // Use the supplied logging service, or fall back to the degenerate logger.\n        this.Log = logService ?? new DegenerateLoggerService();\n    }\n\n    public void MethodThatGeneratesLogEntries()\n    {\n        Log.Info()\n            .Message(\"I am loosely coupled. I do not depend on any logging back-end.\")\n            .Write();\n    }\n}\n</code></pre> <p>The interface supports semantic logging. You can use a simple format string like so:</p> <pre><code>log.Info().Message(\"Sending data {0}\", data).Write();\nlog.Error().Message(\"Exception {0} occurred with error code {1}\", ex.Message, errorCode).Write();\n</code></pre> <p>But this leaves useful information on the table. Extra rich information can be included like so:</p> <pre><code>log.Info().Message(\"Sending data {data}\", data).Write();\nlog.Error()\n    .Message(\"Exception {exception} occurred with error code {error}\")\n    .Property(\"exception\", ex.Message)\n    .Property(\"error\", errorCode)\n    .Exception(ex)\n    .Write();\n</code></pre> <p>In both statements, we are adding property-value pairs to the log. In the first <code>Log.Info()</code> statement this is implicit, whereas in the <code>Log.Error()</code> statement it is made explicit. This extra information may or may not be used by the log renderer, but if its not there then it can't be used! So if in doubt, include extra information where it is appropriate.</p> <p>Again, this feature set is native to NLog so makes for a very lightweight adaptor. When developing adaptors for other logging frameworks, every attempt shouldbe made to preserve as much of the information as possible.</p>"},{"location":"Diagnostics%20and%20Logging/#two-stage-approach-to-logging","title":"Two-stage Approach to Logging","text":"<p>Think of logging as occurring in two distinct stages.</p> <ol> <li>You build the log entry using <code>IFluentLogBuilder</code>, adding all of the relevant information as Properties of the log entry.</li> <li>You send the log entry to the back-end to be rendered on one or more Targets.</li> </ol> <p>Each target may use none, some or all of the information you provided and it may even augment it with additional metadata. As a library developer, you shouldn't be concerned with how the entry will be rendered, stored or how it will be formatted. You should concentrate only on including as much relevant information as is appropriate in your log entries.</p> <p>Multiple targets may be in use and different targets will produce different output from the exact same log entry. For example:</p> <ul> <li>A file target may include a timestamp and perform log file rotation so that a new file is created each day.</li> <li>A debug output stream may include the name of the class where the log entry originated and print only the message portion.</li> <li>A console logger may write different lines in different colours accoring to the severity level.</li> <li>A syslog target may include the host name of the originating computer.</li> <li>A NoSQL database renderer may write out all of the properties as a JSON document.</li> </ul> <p>In most cases, the way in which log data is ultimately rendered is outside of application control. Typically, a configuration file is used. The configuration file may be added or changed post-deployment. As a library developer, you must accept that you have little to no control over this. Just concentrate on including appropriate and useful information and don't think about formatting or storage.</p>"},{"location":"Diagnostics%20and%20Logging/#a-note-on-semantic-logging","title":"A Note on Semantic Logging","text":"<p>If you have always thought about logging as <code>Console.WriteLine()</code> statements, then you have probably focussed on formatting your output and given little thought to the content. You might struggle to see the point of semantic logging and you might be due for a paradigm shift. Forget about how your log output looks and focus on what data it contains. Your responsibility as the log entry creator is to include as much relevant data as possible. Assume that formatting (rendering) and filtering will be done elsewhere and is outside your control.</p> <p>How useful would it be, for example, if when you logged an exception, it included all the exception metadata, any inner exceptions, and a full stack trace? You might struggle to achieve this using <code>Console.WriteLine()</code>. In our paradigm, that is as simple as adding <code>.Exception(ex)</code> to your log builder statement.</p> <p>Having done that, you might think \"so what?\". The log file produced still only shows the exception message, so what was the point? We struggled with this oursleves. You put the data in, but it doesn't easily come out in a meaningful way. Then one day we were \"red-pilled\" by Seq. We discovered the truth that flat files are an inadequate solution for rendering log output.</p> <p>We had our \"Aha!\" moment the first time we logged and exception to Seq and were able to view the full stack trace. There is so much more to Seq, but that was the moment we understood semantic logging. Seq unlocks the full usefulness of all that data and will change the way you write log entries. Once you see the truth, Neo, you cannot go back. You cannot \"unsee\" Seq. We realised that merely by changing a configuration file, i.e. with zero code impact, we could send our log entries across the network to a log server that could store them in a SQL database. We could then use our web browser to log into that server to view the log data, in real time, and be able to view, search, filter and query based on the full data that we put into our log entries.</p> <p>Seq can be used with our logging abstraction and the NLog adapter, and using the NLog.Targets.Seq NuGet package. You can then configure a Seq target for NLog in your NLog.config file (there is no special code needed).</p>"},{"location":"Diagnostics%20and%20Logging/#seq-special-considerations","title":"Seq Special Considerations","text":"<p>We highly recommend Seq. It's free for a single user and can be set up in a few moments using Docker. This section contains some of our explorations with Seq.</p>"},{"location":"Diagnostics%20and%20Logging/#tldr","title":"TL;DR","text":"<ul> <li>Add and ambient property called <code>CorrelationId</code> to all log entries and set it to a new <code>Guid</code> each time the program starts. This helps you find all the log entries relating to a particular run of the program.</li> <li>Register a Last Chance Exception Handler as soon as your program starts; this will let you catch and log any program crashes as they happen. Have your handler log the exception and display a message to the user with the <code>CorrelationId</code> that they should use in any bug reports. This will make it trivial to find the error in the logs.</li> <li>When reporting a <code>CorrelationId</code> to the user, you can use just the last few digits (we use 6) of the <code>CorrelationId</code>, this is usually enough to uniquely identify a log session.</li> <li>Use dependency injection and have your IOC container create loggers for injection into class constructors.</li> </ul> <p>This method may be useful. It was written for use with Ninject, but you can distill out the approach  of looking at the stack frame to work out the calling type and set the logger name from that.</p> <pre><code>/// &lt;summary&gt;\n///     Get an instance of a service from the dependency injection kernel.\n///     Special handling for logging services.\n/// &lt;/summary&gt;\n/// &lt;typeparam name=\"TService\"&gt;The type of service requested.&lt;/typeparam&gt;\n/// &lt;returns&gt;An instance of the requested service.&lt;/returns&gt;\npublic static TService Get&lt;TService&gt;()\n{\n   if (typeof(ILog).IsAssignableFrom(typeof(TService)))\n   {\n       // Special handling for request for ILog.\n       // Try to determine the calling type by examining the stack, and pass it to the kernel as a binding parameter.\n       var callerStackFrame = new StackFrame(1);\n       var callingMethod = callerStackFrame.GetMethod();\n       // MethodBase.ReflectedType is more reliable than the direct Type property and less likely to return an \"un-utterable name\".\n       var callerType = callingMethod.ReflectedType;\n       var callerTypeName = callerType?.Name ?? string.Empty;\n       if (!string.IsNullOrEmpty(callerTypeName))\n       {\n           var logServiceNameParameter = new Parameter(LogSourceParameterName, callerTypeName, false);\n           return Kernel.Get&lt;TService&gt;(logServiceNameParameter);\n       }\n   }\n\n   // For all other requests, simply request the type from the DI kernel.\n    return Kernel.Get&lt;TService&gt;();\n}\n</code></pre>"},{"location":"Diagnostics%20and%20Logging/#log-correlation","title":"Log Correlation","text":"<p>We use a global static readonly GUID called something like <code>CorrelationId</code>. We initialize this with a new <code>Guid</code> as early as possible in the program execution, usually in a static initializer, so that it has a new value for each run of the program. We then add this to every instance of <code>ILog</code> as an Ambient Property.</p> <p>This way, every log entry we write contains a <code>CorrelationId</code> value which is unique for each run of the program. In Seq, you can Expand a log entry, find the <code>CorrelationId</code> property, and click the checkmark next to it, then select \"Find\". This will find all the log entries for one run of the program.</p> <p></p>"},{"location":"Diagnostics%20and%20Logging/#custom-severity-levels","title":"Custom Severity Levels","text":"<p>NLog has fice severity levels: <code>Trace</code>, <code>Debug</code>, <code>Info</code>, <code>Warning</code>, <code>Error</code> and a pseudo-level <code>Fatal</code> which actually causes the program to exit, so can't really be used as a normal severity level.</p> <p>We find this a bit limiting and would like to be able to create our own levels, such as <code>Note</code> and <code>Important</code>.</p> <p>The <code>NLog.Targets.Seq</code> logging target has support for this, and we also support it in our <code>ILog</code> interface via the <code>ILog.Level(string levelName)</code> method.</p> <p>The way this works is to create an additional log event property, by default named \"CustomLevel\", containing the level name. The Seq target then uses this property as the level when it posts the data to the Seq server. If the default property name is no good for some reason, it can be changed using a <code>LogServiceOptions</code> instance and setting <code>LogServiceOptions.CustomSeverityPropertyName</code> property to the preferred name, like so:</p> <pre><code>var options = LogServiceOptions.DefaultOptions.CustomSeverityPropertyName(\"SeqLevel\");\nvar log = new LoggingService(options);\n</code></pre> <p>A small bit of configuration is needed to wire this up, in the Seq target in the <code>NLog.config</code> file, like so:</p> <pre><code>      \\\\&lt;target xsi:type=\"Seq\" name=\"seq\" \n      serverUrl=\"http://your-server-url:5341\"\n      apiKey=\"your-seq-api-key\"\n      seqLevel=\"${event-properties:CustomLevel:whenEmpty=${level}}\"\\\\&gt;\n</code></pre> <p>The magic is in <code>seqLevel=\"${event-properties:CustomLevel:whenEmpty=${level}}</code></p> <p>This uses the value of <code>CustomLevel</code> as the Seq level, unless it is empty or missing, in which case it defaults to the NLog level.</p> <p>In targets other than Seq, this will just appear as yet another log event property.</p>"},{"location":"Home/","title":"Home (vault index)","text":"<p>This page provides a table of contents for easy navigation while editing in Obsidian.</p> <ul> <li>Overview</li> <li>[[Overview|Project Overview]]</li> <li>Versioning (GitVersion + SemVer)</li> <li>Why GitVersion (automation vs. manual)</li> <li>Diagnostics and Logging</li> <li>Diagnostics and Logging</li> <li>Core Utilities</li> <li>SemanticVersion</li> <li>Maybe\\&lt;T&gt;</li> <li>Octet</li> <li>Code Contracts</li> <li>Display Equivalent</li> <li>ASCII Mnemonic Expansion</li> <li>Async Helpers</li> <li>Property Binding</li> <li>String extensions</li> <li>Math extensions</li> <li>Console logger (Diagnostics)</li> <li>Finite State Machine</li> <li>Logging</li> <li>NLog adapter</li> <li>Release Notes</li> <li>Release Notes</li> <li>Areas for Improvement</li> <li>FSM SOLID analysis for Finite State Machine</li> </ul>"},{"location":"Release%20Notes/","title":"Release Notes","text":"<p>2.10.0  - Improved how code contracts handle recording the contract data in the <code>CodeContractViolationException</code>.  - Added the ability to configure logging levels in ConsoleLoggerOptions. The default is to log everything.    - Specific severity levels can be included using RenderSeverityLevels(). Once configured with any value, the default no longer applies so all levels to be logged must be included.    - Specific levels may also be ignored using IgnoreSeverityLevels(). The ignore list takes precedence over the include list.</p> <p>2.9.0 - Added Code Contract assertions that can be used for enforcing code contracts at runtime.   Contract failures result in a <code>CodeContractViolationException</code> being thrown.   The exception records the value being tested, any predicate expression that was used in the test,   and the message that was passed to the assertion method. Any occurrence of a <code>CodeContractViolationException</code>   should be treated as an unambiguous bug in the code and not caught or handled, except to write it out to a log.</p> <p>2.8.1 - Fixed an issue that caused a custom severity property name option to be ignored. </p> <p>2.8.0 - Fixed a formatting bug in <code>Octet.ToString()</code></p> <p>2.7.0 - Added support for custom severity levels in the <code>ILog</code> abstraction and NLog implementation. - Used the \"official\" regular expression to validate semantic version strings. Note: some strings that were previously accepted, such as \"01.02.03\" will no longer be accepted as valid.</p>"},{"location":"Versioning/","title":"Versioning","text":"<p>Timtek has settled on an automated versioning strategy based on Semantic Versioning 2.0.0 and About GitVersion.</p> <p>We give all of our software a semantic version, which we display to the user in the About box and write out to log files on startup. We use GitVersion to automatically assign a version number to every build (even in Arduino projects). We never manually set the version number, it happens as part of the build process. So we can never forget to \"bump the version\" and we can never forget to set it. Total automation. If you examine one of our log files, you may well find something like this:</p> <pre><code>21:16:59.2909|INFO |Server          |Git Commit ID: \"229c1acc4a7bda494f78a8c7cc811c2a4d8e9132\"\n21:16:59.3069|INFO |Server          |Git Short ID: \"229c1ac\"\n21:16:59.3069|INFO |Server          |Commit Date: \"2020-07-11\"\n21:16:59.3069|INFO |Server          |Semantic version: \"0.1.0-alpha.1\"\n21:16:59.3069|INFO |Server          |Full Semantic version: \"0.1.0-alpha.1\"\n21:16:59.3069|INFO |Server          |Build metadata: \"Branch.develop.Sha.229c1acc4a7bda494f78a8c7cc811c2a4d8e9132\"\n21:16:59.3069|INFO |Server          |Informational Version: \"0.1.0-alpha.1+Branch.develop.Sha.229c1acc4a7bda494f78a8c7cc811c2a4d8e9132\"\n</code></pre> <p>There's no mistaking where that build came from.</p>"},{"location":"Versioning/#semanticversion-class","title":"<code>SemanticVersion</code> class","text":"<p>Since we rely heavily on semantic versioning, it is useful to have a class that encapsulates all the rules for parsing, outputting, comparing and sorting semantic versions. That is the function of the <code>SemanticVersion</code> class. With it you can:</p> <ul> <li>Parse a semantic version string;</li> <li>Validate a semantic version string;</li> <li>Format a version for display, logging or printing;</li> <li>Test the equality of two versions using the correct comparison rules;</li> <li>Sort versions using the correct collation rules.</li> </ul>"},{"location":"Versioning/#gitversion-support","title":"GitVersion Support","text":"<p>GitVersion also injects a static class into the assembly containing all the versioning information it computed based on your Git commit history. This information can be a little tricky to get at, because it doesn't exist at compile time so you can't easily reference it. You have to use Reflection to get at it. Our <code>GitVersion</code> class contains static properties for getting your semantic version metadata at runtime. We use it to write the log entries as shown above.</p>"},{"location":"Areas%20for%20Improvement/FSM%20SOLID%20Analysis/","title":"FSM SOLID analysis and recommendations","text":"<p>This document reviews the finite state machine (FSM) design in TA.Utils.Core.StateMachine with respect to the SOLID principles, and proposes pragmatic improvements. It assumes familiarity with Finite State Machine as implemented in this repository.</p> <p>Summary - The design is clean and pragmatic: small, composable abstractions, with a clear split between \"state\" and \"machine\" and sensible use of observability. - The main areas to tighten are: concurrency safety and visibility across threads, transition error handling (especially exceptions from a state\u2019s RunAsync), resource disposal, and API shape.</p> <p>Strengths (per SOLID) - Single Responsibility   - <code>IState</code> encapsulates a state\u2019s lifecycle: enter, run, exit, with a clear cancellation boundary.   - <code>IFiniteStateMachine\\&lt;TState\\&gt;</code> focuses on orchestration and observation (start/stop/transition + observability).   - <code>FiniteStateMachine\\&lt;TState\\&gt;</code> centralises transition sequencing: cancel current, wait, exit, enter, run next. - Open\u2013Closed   - Virtual methods permit extension via subclassing without modifying core code.   - Logging depends on <code>ILog</code> and remains pluggable. - Liskov Substitution   - The <code>IState</code> contract is straightforward; implementations can substitute so long as they honour cancellation and lifecycle hooks. - Interface Segregation   - <code>IState</code> and <code>IFiniteStateMachine\\&lt;TState\\&gt;</code> are small and coherent. - Dependency Inversion   - Depends on abstractions (<code>IState</code>, <code>ILog</code>, <code>IObservable</code>) rather than concrete frameworks.</p> <p>Weaknesses and risks - Scope creep in the core class (SRP pressure)   - <code>FiniteStateMachine\\&lt;TState\\&gt;</code> handles orchestration, concurrency/cancellation, signalling, event publication and logging. This increases the reasons for the class to change. - Limited extension points (OCP pressure)   - No injection point for custom scheduling, transition guards, timeout policies, or exception handling strategies. Subclassing risks invariant breakage. - Invariants are not formalised (LSP risk)   - Transition semantics are not strictly documented; overrides could violate cancellation/ordering guarantees. A public <code>ManualResetEvent</code> leaks an implementation detail a subclass might change. - Interface details   - <code>DisplayName</code> on <code>IState</code> is UI\u2011oriented; some domains may not wish to couple display concerns into the core interface. - API leakage and synchronisation primitive   - Exposing <code>ManualResetEvent</code> couples consumers to a particular synchronisation model; an awaitable API would be a better abstraction. - Concurrency/thread safety   - No explicit locking around <code>CurrentState</code>/<code>currentStateTask</code>/<code>stateCancellation</code>. Concurrent <code>TransitionTo</code> calls can interleave.   - <code>Subject&lt;T&gt;</code> emissions occur on background threads; consumers may incorrectly assume a context. - Error handling of state failures   - Only <code>OperationCanceledException</code> is caught when waiting for the prior state; unexpected exceptions from <code>RunAsync</code> could become unobserved or skip completion signalling. - Resource disposal   - The previous <code>CancellationTokenSource</code> is replaced but never disposed; repeated transitions can leak handles. - Logging responsibility   - Logging inside the core class conflicts with the repository preference for a logging decorator. - Test synchronisation ergonomics   - Exposing <code>ManualResetEvent</code> invites blocking APIs; async/await would be more idiomatic and composable.</p> <p>Recommendations 1) Serialise transitions and protect shared state - Use a private lock or a serial queue to ensure <code>TransitionTo</code> is processed one at a time and to protect <code>CurrentState</code>, <code>currentStateTask</code>, <code>stateCancellation</code> and the <code>stopped</code> flag.</p> <p>2) Dispose the previous <code>CancellationTokenSource</code> - Swap, cancel, and dispose the old CTS to avoid leaking OS handles.</p> <pre><code>// inside CancelCurrentState()\nvar old = Interlocked.Exchange(ref stateCancellation, new CancellationTokenSource());\ntry { old.Cancel(); } catch (ObjectDisposedException) { }\nold.Dispose();\n</code></pre> <p>3) Catch and log all exceptions from state tasks and waits - Ensure the transition path cannot fault and skip completion signalling; log unexpected exceptions at Error and proceed.</p> <pre><code>try\n{\n    currentStateTask?.Wait();\n}\ncatch (OperationCanceledException ex)\n{\n    log.Warn().Exception(ex).Message(\"State cancelled while awaiting completion\").Write();\n}\ncatch (Exception ex)\n{\n    log.Error().Exception(ex).Message(\"Unhandled exception from state RunAsync: {message}\", ex.Message).Write();\n}\n</code></pre> <p>4) Replace <code>ManualResetEvent</code> with an awaitable API - Add <code>TransitionAsync(next, ct)</code> that completes when the new state is fully activated (after <code>OnEnter</code> and <code>RunAsync</code> is scheduled). Retain the event internally for tests if required.</p> <pre><code>public Task TransitionAsync(TState next, CancellationToken ct = default)\n{\n    var tcs = new TaskCompletionSource();\n    TransitionTo(next);\n    Task.Run(() =&gt;\n    {\n        StateChanged.WaitOne();\n        tcs.TrySetResult();\n    }, ct);\n    return tcs.Task;\n}\n</code></pre> <p>5) Introduce extension points (favour composition) - <code>ITransitionScheduler</code> \u2013 how transitions are queued/executed. - <code>IExceptionPolicy</code> \u2013 how to deal with exceptions from <code>OnExit</code>/<code>RunAsync</code> (log, rethrow, transition to fallback). - <code>ITransitionGuard</code> \u2013 optional policy to allow/deny a transition.</p> <p>6) Seal the core class and add a logging decorator - Seal <code>FiniteStateMachine\\&lt;TState\\&gt;</code> to protect invariants. - Move logging into a <code>FiniteStateMachineLoggingDecorator\\&lt;TState\\&gt;</code> that wraps <code>IFiniteStateMachine\\&lt;TState\\&gt;</code> and logs around calls.</p> <p>7) Provide async\u2011first APIs - Add <code>StartAsync</code>, <code>TransitionAsync</code>, <code>StopAsync</code> (with optional timeouts). Keep synchronous counterparts for convenience, but prefer async in usage and examples.</p> <p>8) Document or parameterise the observer context - Clearly document that <code>ObservableStates</code> emits on background threads, or accept an <code>IScheduler</code> to marshal notifications.</p> <p>9) Optional: make state publication replayable - Provide a way for late subscribers to receive the current state immediately (e.g., cache last activation and emit it on subscription).</p> <p>10) Consider decoupling display concerns - Make <code>DisplayName</code> optional or move UI\u2011oriented concerns to a separate optional interface.</p> <p>11) Add transition timeouts and fallbacks - Ensure a misbehaving state that ignores cancellation cannot block shutdown indefinitely; log at Error and move to a safe state after a timeout.</p> <p>12) Extend the test suite for race and failure modes - Add specs for rapid sequential transitions, Stop during a transition, exceptions thrown by <code>RunAsync</code>, and <code>OnExit</code> throwing. Assert that invariants hold and notifications always complete.</p> <p>Expected benefits - Stronger invariants and simpler reasoning about concurrency. - Cleaner API surface (async/await rather than synchronisation primitives). - Alignment with repository preferences (sealed by default; logging via decorator). - Improved testability and resilience, with pluggable policies. - Fewer leaks and unobserved exceptions; more graceful behaviour under failure.</p> <p>Related topics - Finite State Machine - Async Helpers - Diagnostics and Logging</p>"},{"location":"Core/ASCII%20Mnemonic%20Expansion/","title":"ASCII Mnemonic Expansion","text":"<p>When dealing with streams of ASCII-encoded data, it is often helpful to be able to see non-printing and white space characters. This is especially useful when logging. The <code>ExpandAscii()</code> extension method makes this simple. Us <code>string.ExpansAscii()</code> and cahacters such as carriage return, for example, will be rendered as <code>\\&lt;CR\\&gt;</code> instead of causing an ugly line break in your log output.</p> <p><code>ExpandAscii()</code> uses the mnemonics defined in the <code>AsciiSymbols</code> enumerated type.</p>"},{"location":"Core/Async%20Helpers/","title":"Asynchrony and Threading","text":""},{"location":"Core/Async%20Helpers/#configureawait","title":"ConfigureAwait","text":"<p>There is an extension method in .NET used to configure awaitable tasks, called <code>ConfigureAwait(bool)</code>. The method affects how the task awaiter schedules its continuation. With <code>ConfigureAwait(true)</code> the task continues on the current synchronization context. That usually means on the same thread, and is particularly relevant when the awaiter is a user interface thread. Conversely, <code>ConfigureAwait(false)</code> means that continuation can happen on any thread,  and typically that will be a thread pool worker thread. The implications are quite profound, especially for apartment-threaded GUI applications such as WinForms or WPF.  Consider the following method:</p> <pre><code>public async Task SomeMethod()\n    {\n    Console.WriteLine(\"Starting on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    await Task.Delay(1000).ConfigureAwait(false);\n    Console.WriteLine(\"Continuing on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    }\n</code></pre> <p>When you run this, you may get something like</p> <p>Starting on thread 14 Continuing on thread 11</p> <p>But it is not at all ovious how <code>ConfigureAwait()</code> should be used. What if you don't specifiy? Is the await configured or unconfigured? Does <code>ConfigureAwait(false)</code> mean you don't want to configure it, or that you want to configure it not to do something? It's just horrible. You can't read the code and instantly understand what it does, and that violates the Principle of Least Astonishment.</p> <p>So we made some extension methods that essentially do the same thing, but make more sense. Our aync method now becomes:</p> <pre><code>public async Task SomeMethod()\n    {\n    Console.WriteLine(\"Starting on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    await Task.Delay(1000).ContinueOnAnyThread();\n    Console.WriteLine(\"Continuing on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    }\n</code></pre> <p>and we get</p> <p>Starting on thread 15 Continuing on thread 13</p> <p>Alternatively:</p> <pre><code>public async Task SomeMethod()\n    {\n    Console.WriteLine(\"Starting on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    await Task.Delay(1000).ContinueInCurrentContext();\n    Console.WriteLine(\"Continuing on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    }\n</code></pre> <p>The await captures the current <code>SynchronizationContext</code> and uses it to schedule the continuation. What happens next depends on the application model and how it implements <code>SynchronizationContext</code>. For a user interface application, the UI generally runs in a Single Threaded Apartment (STA thread). In this model, asynchronous operations are posted to the message queue of the STA thread. The continuation will then happen on the UI thread once the thread is idle and the message pump runs. In a free-threaded application model such as a console application, the continuation will likely still happen on a different thread.</p> <p>Here you can see the danger of this option. If the continuation is queued in the message queue waiting for messages to be pumped, but the UI is blocked waiting for the task to complete, then the continuation may never get to run. The task is prevented from completing and we are in deadlock. Therefore, best practice for library writers is to always use <code>ContinueOnAnyThread()</code>.</p>"},{"location":"Core/Async%20Helpers/#cancel-culture","title":"Cancel Culture","text":"<p>One final extension method is <code>Task.WithCancellation(token)</code>. This takes a task that is not cancellable and wraps it in a cancellable task. Awaiters can then wait on the cancellable wrapper and will get to run if the wrapper is cancelled. Note that this doesn't stop the original task from running and it may still run to completion, but its result will be discarded as there should be nothing awaiting the result.</p>"},{"location":"Core/Code%20Contracts/","title":"Code Contract Assertions","text":"<p>A set of extension methods for making runtime assertions that can help to catch code contract violations.</p> <pre><code>void AddUserToDatabase(User user)\n{\n    // Check that the user is not null and that the age is greater than 18.\n    user.ContractAssertNotNull();\n    user.Age.ContractAssert(p =&gt; p &gt; 18, \"Age must be greater than 18\");\n}\n</code></pre> <p>Any assertion failure will result in a <code>ContractViolationException</code> being thrown. It is recommended not to catch these exceptions, but to let them bubble up to the application root where they can be logged and the application terminated cleanly. A <code>ContractViolationException</code> is an unequivocal indication of a bug in the code, so it should never be caught and handled. It is a failure of the code contract, not a runtime error that can be recovered from.</p>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/","title":"Console logger (Diagnostics)","text":"<p>A minimal, dependency\u2011free console implementation of the logging abstraction, useful for small tools and early development. It implements <code>ILog</code>/<code>IFluentLogBuilder</code> and writes entries to the console with optional property rendering and verbosity support.</p> <ul> <li>Class: <code>ConsoleLoggerService</code></li> <li>Builder: <code>ConsoleLogBuilder</code></li> <li>Options: <code>ConsoleLoggerOptions</code></li> </ul>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#quick-start","title":"Quick start","text":"<pre><code>var options = ConsoleLoggerOptions.DefaultOptions\n    .UseVerbosity()\n    .RenderProperties(true)\n    .RenderSeverityLevels(\"Info\", \"Warn\", \"Error\");\n\nILog log = new ConsoleLoggerService(options);\nlog.Info(2).Message(\"Hello {who}\").Property(\"who\", \"world\").Write();\n</code></pre>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#options","title":"Options","text":"<ul> <li>UseVerbosity(propertyName = \"verbosity\")</li> <li>Adds a property to each entry (default name \"verbosity\"). The number passed to the severity method is recorded.</li> <li>Example: <code>log.Info(2)</code> \u2192 property <code>{ verbosity: 2 }</code>.</li> <li>RenderProperties(enable = true)</li> <li>Controls whether the property bag is emitted to the console. Enabled by default.</li> <li>RenderAllSeverityLevels()</li> <li>Resets filtering so that all severities are shown (the default unless modified).</li> <li>RenderSeverityLevels(params string[] levels)</li> <li>An allow\u2011list for severities to render (e.g., \"Info\", \"Warn\", \"Error\"). Removing a level implicitly overrides previous includes.</li> <li>IgnoreSeverityLevels(params string[] levels)</li> <li>A deny\u2011list; takes precedence over the allow\u2011list.</li> </ul> <p>Behaviour - If Ignore includes a level, it is not rendered. - If Render list is empty, all levels are rendered by default.</p>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#ambient-properties-and-names","title":"Ambient properties and names","text":"<ul> <li><code>WithAmbientProperty(name, value)</code> adds a property to all subsequent entries.</li> <li><code>WithName(source)</code> sets the logger\u2019s source name for downstream filtering or routing.</li> </ul>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#reentrancy-guard-optional","title":"Re\u2011entrancy guard (optional)","text":"<p>To prevent recursive log writes (e.g., logging during serialisation) you can wrap any logger in the guard decorator:</p> <pre><code>ILog baseLog = new ConsoleLoggerService();\nILog log = new ReentrancyGuardLog(baseLog);\n</code></pre> <p>If a write is attempted while another write is in progress on the same async\u2011flow, the nested write is dropped.</p> <p>See also - Diagnostics and Logging - ASCII Mnemonic Expansion</p>"},{"location":"Core/Display%20Equivalent/","title":"Display Equivalence for Enumerated Types","text":"<p>The <code>[DisplayEquivalent(\"text\")]</code> Attribute works with the <code>EnumExtensions.DisplayEquivalent()</code> extension method. This can be useful for building drop-down lists and Combo box contents for enumerated types, or anywhere that a human-readable version of an Enum member name is needed. You can always get the equivalent human-readable display text for an enumerated value using <code>value.DisplayEquivalent()</code>. This will return the display text if it has been set, or the name of the enum value otherwise. Set the display text by dropping a <code>[DisplayEquivalent(\"text\")]</code> attribute on each field of the enum.</p> <pre><code>[Subject(typeof(DisplayEquivalentAttribute))]\ninternal class when_displaying_an_enum_with_equivalent_text\n    {\n    It should_have_equivalent_text_when_the_attribute_is_present = () =&gt;\n        TestCases.CaseWithEquivalentText.DisplayEquivalent().ShouldEqual(\"Equivalent Text\");\n    It should_use_the_field_name_when_no_attribute_is_present = () =&gt;\n        TestCases.CaseWithoutEquivalentText.DisplayEquivalent()\n            .ShouldEqual(nameof(TestCases.CaseWithoutEquivalentText));\n    }\n\ninternal enum TestCases\n    {\n    [DisplayEquivalent(\"Equivalent Text\")] CaseWithEquivalentText,\n    CaseWithoutEquivalentText\n    }\n</code></pre>"},{"location":"Core/Finite%20State%20Machine/","title":"Finite State Machine (FSM)","text":"<p>This package provides a lightweight, composable finite state machine for orchestrating asynchronous workflows. It is designed to be simple enough for embedded or real\u2011time adjacent scenarios while remaining idiomatic for .NET applications.</p> <ul> <li>Interfaces: <code>IState</code>, <code>IFiniteStateMachine&lt;TState&gt;</code></li> <li>Implementation: <code>FiniteStateMachine&lt;TState&gt;</code></li> <li>Cross\u2011cutting: integrates cleanly with Diagnostics and Logging and Async Helpers</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#why-use-an-fsm","title":"Why use an FSM?","text":"<p>An FSM is a robust way to model systems that have a small number of modes of operation with well\u2011defined rules for moving between them. Typical examples include: - Device and protocol controllers (Idle \u2192 Connecting \u2192 Connected \u2192 Error \u2192 Reconnect) - UI or workflow wizards (Start \u2192 Collecting Input \u2192 Validating \u2192 Completed/Failed) - Stream/transport handlers (Listening \u2192 Handshaking \u2192 Streaming \u2192 Closing)</p> <p>Benefits - Deterministic behaviour: states explicitly define entry, run, and exit behaviour. - Clear separation of concerns: each state has a single responsibility. - Testability: transitions and hooks are easy to verify (see the included specifications). - Safe shutdown/transition: the framework cancels the running state and waits for it to exit before activating the next state. - Observability: transitions are published via <code>IObservable</code> so other components can react.</p> <p>Real\u2011time considerations - Bounded transitions: when <code>TransitionTo()</code> is called, the framework cancels the old state and only starts the new state after the old state\u2019s <code>RunAsync</code> completes and <code>OnExit</code> has run. This prevents overlap and race conditions. - No UI thread dependence: states run on background tasks (<code>Task.Run</code>) and use ContinueOnAnyThread semantics, avoiding message\u2011pump deadlocks. - Cooperative cancellation: each state\u2019s <code>RunAsync(CancellationToken)</code> cooperates to exit promptly on cancellation, allowing responsive hand\u2011overs.</p>"},{"location":"Core/Finite%20State%20Machine/#programming-model","title":"Programming model","text":"<p>Implement the <code>IState</code> interface for each state and drive transitions through <code>IFiniteStateMachine&lt;TState&gt;</code>.</p> <pre><code>public interface IState\n{\n    string DisplayName { get; }\n    void OnEnter();\n    void OnExit();\n    Task RunAsync(CancellationToken cancelOnExit);\n}\n</code></pre> <pre><code>public interface IFiniteStateMachine&lt;TState&gt; where TState : class, IState\n{\n    void TransitionTo(TState newState);\n    void StartStateMachine(TState initialState);\n    void StopStateMachine();\n\n    IObservable&lt;TState&gt; ObservableStates { get; }\n    TState? CurrentState { get; }\n}\n</code></pre> <p>Key runtime guarantees - Cancellation first: <code>TransitionTo(next)</code> cancels the current state\u2019s token before waiting. - Orderly exit/enter: after the current state\u2019s run task completes, <code>OnExit()</code> is called, then <code>OnEnter()</code> for the next state, then <code>RunAsync()</code> for the next state is started. - Transition completion signal: the FSM exposes a <code>StateChanged</code> event (ManualResetEvent) that is set once a transition fully completes, useful in tests or host loops. - Observable transitions: each activation is pushed to <code>ObservableStates</code>.</p>"},{"location":"Core/Finite%20State%20Machine/#minimal-example","title":"Minimal example","text":"<p>Below is a simplified controller with three states: Idle, Connecting, Connected. The Connecting state simulates work and then transitions to Connected; Connected waits until cancelled.</p> <pre><code>using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TA.Utils.Core.Diagnostics;\nusing TA.Utils.Core.StateMachine;\n\npublic class IdleState : IState\n{\n    public string DisplayName =&gt; \"Idle\";\n    private readonly Action&lt;IState&gt; go;\n\n    public IdleState(Action&lt;IState&gt; transition)\n        =&gt; go = transition;\n\n    public void OnEnter() { /* noop */ }\n    public void OnExit()  { /* noop */ }\n\n    public Task RunAsync(CancellationToken cancel)\n    {\n        // Immediately move to Connecting\n        go(new ConnectingState(go));\n        return Task.CompletedTask;\n    }\n}\n\npublic class ConnectingState : IState\n{\n    public string DisplayName =&gt; \"Connecting\";\n    private readonly Action&lt;IState&gt; go;\n\n    public ConnectingState(Action&lt;IState&gt; transition) =&gt; go = transition;\n\n    public void OnEnter() { /* start timers, allocate resources */ }\n    public void OnExit()  { /* release temporary resources */ }\n\n    public async Task RunAsync(CancellationToken cancel)\n    {\n        try\n        {\n            // Simulate connection establishment\n            await Task.Delay(500, cancel).ConfigureAwait(false);\n            go(new ConnectedState());\n        }\n        catch (OperationCanceledException)\n        {\n            // Transition or stop was requested\n        }\n    }\n}\n\npublic class ConnectedState : IState\n{\n    public string DisplayName =&gt; \"Connected\";\n    public void OnEnter() { /* mark online */ }\n    public void OnExit()  { /* mark offline */ }\n\n    public async Task RunAsync(CancellationToken cancel)\n    {\n        // Run until cancelled by a transition or StopStateMachine()\n        try\n        {\n            while (!cancel.IsCancellationRequested)\n                await Task.Delay(100, cancel).ConfigureAwait(false);\n        }\n        catch (OperationCanceledException) { }\n    }\n}\n\n// Host\nvar log = new DegenerateLoggerService();\nvar fsm = new FiniteStateMachine&lt;IState&gt;(log);\n\n// Helper to allow states to request transitions without holding fsm directly.\nvoid Go(IState next) =&gt; fsm.TransitionTo(next);\n\nvar idle = new IdleState(Go);\nfsm.StartStateMachine(idle);\n</code></pre> <p>Notes - States can trigger transitions by holding an <code>Action&lt;IState&gt;</code> (or a reference to the FSM) passed via constructor DI. - Keep <code>OnEnter</code>/<code>OnExit</code> fast; perform long work inside <code>RunAsync</code>. - Always observe the <code>cancelOnExit</code> token and exit promptly on cancellation.</p>"},{"location":"Core/Finite%20State%20Machine/#observing-transitions","title":"Observing transitions","text":"<p>Other components can subscribe to state activations.</p> <pre><code>var subscription = fsm.ObservableStates.Subscribe(s =&gt;\n{\n    Console.WriteLine($\"Now in state: {s.DisplayName}\");\n});\n</code></pre> <p>In tests or synchronous orchestration, you can wait for a transition to complete:</p> <pre><code>fsm.TransitionTo(new ConnectedState());\nfsm.StateChanged.WaitOne(); // transition completed (enter/run scheduled)\n</code></pre>"},{"location":"Core/Finite%20State%20Machine/#error-handling-and-logging","title":"Error handling and logging","text":"<ul> <li>Exceptions in <code>RunAsync</code> should generally be caught inside the state and handled by transitioning to an error/recovery state.</li> <li>Exceptions in <code>OnExit</code> are caught by the FSM and logged, to avoid derailing the transition.</li> <li>Use Diagnostics and Logging to attach per\u2011state context (e.g., logger name, correlation ids).</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#timeouts-timers-and-external-events","title":"Timeouts, timers, and external events","text":"<ul> <li>Use <code>Task.WhenAny</code>, <code>Task.Delay(timeout, cancel)</code> or external event sources to decide when to transition.</li> <li>For periodic work, loop inside <code>RunAsync</code> with <code>await Task.Delay(...)</code> observing <code>cancelOnExit</code>.</li> <li>For external events (I/O, message bus), subscribe in <code>OnEnter</code> and unsubscribe in <code>OnExit</code>.</li> </ul> <p>Example: transition on timeout or signal, whichever comes first.</p> <pre><code>public class WaitingForSignal : IState\n{\n    public string DisplayName =&gt; \"WaitingForSignal\";\n    private readonly Action&lt;IState&gt; go;\n    private readonly TaskCompletionSource&lt;bool&gt; signal = new();\n\n    public WaitingForSignal(Action&lt;IState&gt; transition) =&gt; go = transition;\n    public void OnEnter() { /* wire external event =&gt; signal.TrySetResult(true) */ }\n    public void OnExit()  { /* unwire */ }\n\n    public async Task RunAsync(CancellationToken cancel)\n    {\n        var timeout = Task.Delay(TimeSpan.FromSeconds(2), cancel);\n        var completed = await Task.WhenAny(signal.Task, timeout).ConfigureAwait(false);\n        if (completed == signal.Task) go(new ConnectedState());\n        else go(new IdleState(go));\n    }\n}\n</code></pre>"},{"location":"Core/Finite%20State%20Machine/#best-practices","title":"Best practices","text":"<ul> <li>Keep state objects small, immutable where possible, and focused on one responsibility (SRP).</li> <li>Prefer composition: delegate specialized work (I/O, parsing) to collaborators injected into the state.</li> <li>Avoid blocking waits inside <code>RunAsync</code>\u2014always prefer async and honor cancellation.</li> <li>Design explicit Error/Recovering states rather than mixing error handling into every state.</li> <li>Publish enough metadata via logging to trace complex sequences (see Diagnostics and Logging and correlation guidance).</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#api-reference-summary","title":"API reference (summary)","text":"<ul> <li><code>IState</code></li> <li><code>DisplayName</code> \u2013 human\u2011readable identifier for diagnostics/UI</li> <li><code>OnEnter()</code> \u2013 called after previous state exits, before <code>RunAsync</code></li> <li><code>OnExit()</code> \u2013 called during transition out, after <code>RunAsync</code> completes</li> <li><code>RunAsync(CancellationToken)</code> \u2013 the main loop/logic; must observe cancellation</li> <li><code>IFiniteStateMachine&lt;TState&gt;</code></li> <li><code>StartStateMachine(TState initial)</code> \u2013 activates the initial state</li> <li><code>TransitionTo(TState next)</code> \u2013 cancels current state, waits, then activates <code>next</code></li> <li><code>StopStateMachine()</code> \u2013 cancels and exits, completes the observable, resets to inactive</li> <li><code>ObservableStates</code> \u2013 <code>IObservable&lt;TState&gt;</code> emitting each activated state</li> <li><code>CurrentState</code> \u2013 currently active state or null when stopped</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#see-also","title":"See also","text":"<ul> <li>Async Helpers \u2013 avoiding context capture and UI deadlocks</li> <li>Diagnostics and Logging \u2013 adding semantic logging to states and transitions</li> <li>Versioning \u2013 how the repository versions assemblies and packages</li> </ul>"},{"location":"Core/Math%20Extensions/","title":"Math extensions","text":"<p>Utility methods for simple mathematical operations not provided by the BCL.</p>"},{"location":"Core/Math%20Extensions/#clipminimum-maximum","title":"Clip(minimum, maximum) <p>Constrains a comparable value to a closed interval [minimum, maximum]. Works with any <code>T : IComparable</code>.</p> <pre><code>5.2.Clip(0.0, 5.0);   // 5.0\n(-1).Clip(0, 10);      // 0\n'c'.Clip('a', 'b');    // 'b'\n</code></pre> <p>Notes - If <code>input &gt; maximum</code>, returns <code>maximum</code>; if <code>input &lt; minimum</code>, returns <code>minimum</code>; otherwise returns <code>input</code>. - For reference types that implement <code>IComparable</code>, semantics follow the type\u2019s comparison implementation.</p>","text":""},{"location":"Core/Maybe/","title":"<code>Maybe&lt;T&gt;</code>","text":"<p>One of the most insidious bug producers in .NET code is the null value. Do you return <code>null</code> to mean \"no value\"? What's the caller supposed to do with that? Did you mean there was an error? Did you mean there wasn't an error but you can't give an answer? Did you mean the answer was empty? Or did someone just forget to initialize the variable?</p> <p>I wrote this class long before Microsoft came up with their oddly-named nullable reference types feature, and I'm not a fan of Microsoft's solution to the Null Reference problem. I think their Nullable Reference Types [sic] are clumsy and make the code look ugly and noisy. They couldn't even get the name right - reference types were always nullable! Perhaps I'm biased because this is the way I chose to solve that problem, but I still prefer to use <code>Maybe&lt;T&gt;</code> to clearly communicate my intent to my users.</p> <p>The ambiguity around \"error\" vs. \"no value\" is why we created <code>Maybe&lt;T&gt;</code>.</p> <p><code>Maybe&lt;T&gt;</code> is a type that either has a value, or doesn't, but it is never null. The idea is that by using a <code>Maybe&lt;T&gt;</code> you clearly communicate your intentions to the caller. By returning <code>Maybe&lt;T&gt;</code> you nail down the ambiguity: \"there might not be a value and you have to check\".</p> <p>Strictly, a <code>Maybe&lt;T&gt;</code> is an <code>IEnumerable&lt;T&gt;</code> which is either empty (no value) or has exactly one element. Because it is <code>IEnumerable</code> you can use certain LINQ operators:</p> <ul> <li><code>maybe.Any()</code> will be true if there is a value.</li> <li><code>maybe.Single()</code> gets you the value.</li> <li><code>maybe.SingleOrDefault()</code> gets you the value or <code>null</code>, if you really wanted a null.</li> </ul> <p>Creating a maybe can be done by:</p> <ul> <li><code>object.AsMaybe();</code> - wrap a non-null object.</li> <li><code>Maybe&lt;int&gt;.From(7);</code> - works with value types, and also safe for null references.</li> <li><code>Maybe&lt;T&gt;.Empty</code> - a maybe without a value.</li> </ul> <p><code>Maybe&lt;T&gt;</code> has a <code>ToString()</code> method so you can write it to a stream or use in a string interpolation, and you will get the serialized value or \"<code>{no value}</code>\".</p> <p>Try returning a <code>Maybe&lt;T&gt;</code> whenever you have a situation wehere there may be no value, instead of <code>null</code>. You may find that your bug count tends to diminish.</p>"},{"location":"Core/Octet/","title":"Octet","text":"<p>An <code>Octet</code> is an immutable type that represents 8 bits, or a byte and provides bit-manipulation operators.</p> <p>In most cases, <code>Octet</code> can be directly used in place of a <code>byte</code> as there are implicit conversions to and from a <code>byte</code>. There are also explicit conversions to and from <code>int</code>. The latter is explicit because there is potentially data loss, so use with care.</p> <p>Note that conversion from <code>uint</code> has been deprecated because <code>uint</code> is not CLS Compliant, which can cause issues with other languages.</p> <p>In an <code>Octet</code>, each bit position is directly addressable as an array element. You can access <code>octet[0]</code> through <code>octet[7]</code> to read bit values.</p> <p>You can set a bit with <code>octet.WithBitSet(n)</code>. You can clear a bit with <code>octet.WithBitClear(n)</code>.</p> <p>Remember <code>Octet</code> is immutable so this gives you a new <code>Octet</code> and leaves the original unchanged.</p> <p>You can perform logical bitwise operations using the <code>&amp;</code> anf <code>|</code> operators. You can test octets for equality and compare them using <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>\\&lt;</code>, etc.</p>"},{"location":"Core/Property%20Binding/","title":"Property Binding Utilities","text":"<p>The property binding helpers enable you to populate plain C# objects from simple key\u2013value data, such as INI\u2011style text files, configuration dumps, or instrument logs. You describe how fields map to properties using a small attribute, and a binder performs type conversion and assignment for you.</p> <p>Components - Data source: a sequence of <code>KeyValueDataRecord</code> instances - Reader: <code>KeyValueReader</code> turns a text stream into <code>KeyValueDataRecord</code> items - Attribute: <code>DataKeyAttribute</code> decorates properties with the key name and an optional sequence - Binder: <code>PropertyBinder</code> maps records to properties, including collections</p> <p>Typical use cases - Importing device or test logs into typed DTOs - Parsing simple configuration files for applications and utilities - Converting textual dumps into strongly typed objects for validation and processing</p>"},{"location":"Core/Property%20Binding/#keyvalue-text-format","title":"Key\u2013value text format","text":"<ul> <li>One pair per line, with a delimiter between key and value. Default delimiters: <code>:</code> <code>=</code> <code>#</code>.</li> <li>Lines beginning with a comment character are ignored. Default comment openers: <code>#</code>.</li> <li>Whitespace around keys and values is trimmed.</li> <li>Lines that cannot be parsed into a pair are skipped.</li> </ul> <p>You can override delimiters and comment characters when constructing <code>KeyValueReader</code>.</p> <pre><code>using var stream = File.OpenRead(path);\nusing var reader = new KeyValueReader(stream, delimiters: new[] { ':', '=' }, commentChars: new[] { '#', ';' });\nIEnumerable&lt;KeyValueDataRecord&gt; records = reader.KeyValueDataRecords();\n</code></pre>"},{"location":"Core/Property%20Binding/#decorating-a-target-type","title":"Decorating a target type","text":"<p>Annotate properties with <code>DataKeyAttribute</code> when the key name differs from the property name, or when you want to supply multiple fallbacks and ordering using <code>Sequence</code>.</p> <pre><code>public sealed class DeviceInfo\n{\n    // Matches either the explicit key \"model\" or, if omitted, the property name \"Model\" (case\u2011insensitive)\n    [DataKey(\"model\")]\n    public string Model { get; set; }\n\n    // Multiple fallbacks with ordered preference\n    [DataKey(\"serial\", Sequence = 0)]\n    [DataKey(\"sn\",     Sequence = 1)]\n    public string SerialNumber { get; set; }\n\n    // Collection properties must use DataKeyAttribute; all matching values are added\n    [DataKey(\"alias\")]\n    [DataKey(\"alt_name\")] // both keys, accumulated\n    public List&lt;string&gt; Aliases { get; set; }\n}\n</code></pre> <p>Rules - If one or more <code>DataKeyAttribute</code> decorations are present, their <code>Keyword</code> values are used in ascending <code>Sequence</code> order to search for matching records. - If no attribute is present, the property\u2019s name is used as the key (case\u2011insensitive). - For simple properties, the first successfully converted value is assigned. - For collection properties that implement <code>IList</code> or <code>IList&lt;T&gt;</code>, all matching values across all specified keys are converted and added to the collection.</p>"},{"location":"Core/Property%20Binding/#binding","title":"Binding","text":"<p>Create a binder and produce an instance of your DTO from a sequence of records. The binder logs diagnostic information via the repository\u2019s logging abstraction.</p> <pre><code>var binder = new PropertyBinder();\nDeviceInfo dto = binder.BindProperties&lt;DeviceInfo&gt;(records);\n</code></pre> <p>Behaviour when keys are missing or conversion fails - If no matching record is found for a property, the property is left at its default value. - If conversion fails for a record, the binder logs an error and leaves the property unchanged. Other properties continue to bind.</p>"},{"location":"Core/Property%20Binding/#type-conversion","title":"Type conversion","text":"<p>The binder uses <code>TypeDescriptor</code> to convert strings to the destination type using <code>InvariantCulture</code>. Special cases: - Strings are trimmed and returned as\u2011is. - <code>Nullable&lt;T&gt;</code> is supported; the underlying type is used for conversion. - For custom types, provide a <code>TypeConverter</code> or bind as <code>string</code> and convert later.</p> <p>Examples</p> <pre><code>public sealed class Reading\n{\n    public string Id { get; set; }\n    public int Count { get; set; }              // \"42\" \u2192 42\n    public double TemperatureC { get; set; }    // \"23.5\" \u2192 23.5 (invariant culture)\n    public DateTime Timestamp { get; set; }     // \"2025-09-23T10:00:00Z\" \u2192 DateTime\n    public int? OptionalLevel { get; set; }     // supports Nullable&lt;int&gt;\n}\n</code></pre> <pre><code>var text = @\"\n# Device log\nmodel = ZX-200\nserial = A1B2C3\nalias = \"\"Alpha Unit\"\"\nalt_name = \"\"Primary\"\"\nCount: 42\nTemperatureC: 23.5\nTimestamp: 2025-09-23T10:00:00Z\n\";\nusing var ms = new MemoryStream(Encoding.UTF8.GetBytes(text));\nusing var reader = new KeyValueReader(ms);\nvar records = reader.KeyValueDataRecords();\n\nvar binder = new PropertyBinder();\nvar info = binder.BindProperties&lt;DeviceInfo&gt;(records);\nvar reading = binder.BindProperties&lt;Reading&gt;(records);\n</code></pre>"},{"location":"Core/Property%20Binding/#collections","title":"Collections","text":"<p>When a destination property implements <code>IList</code> or <code>IList&lt;T&gt;</code>, property binding will: - Require <code>DataKeyAttribute</code> on the property to specify which keys to aggregate. - Convert all matching values across all listed keys. - Instantiate the target collection type if it is a concrete <code>IList</code> implementation; otherwise, create a <code>List&lt;T&gt;</code> at runtime and assign it to the property.</p> <pre><code>public sealed class Tags\n{\n    [DataKey(\"tag\")]\n    [DataKey(\"label\", Sequence = 1)]\n    public IList&lt;string&gt; Values { get; set; }\n}\n</code></pre> <p>Input like:</p> <pre><code>label = good\nlabel = fast\ntag = cheap\n</code></pre> <p>binds to <code>Values = [\"good\", \"fast\", \"cheap\"]</code> (order follows appearance in the data).</p>"},{"location":"Core/Property%20Binding/#case-sensitivity-and-ordering","title":"Case sensitivity and ordering","text":"<ul> <li>Key lookup is case\u2011insensitive.</li> <li>When multiple <code>DataKeyAttribute</code>s decorate a property, they are processed in ascending <code>Sequence</code> order.</li> <li>For simple properties, the first found value wins. For collections, all matching values are accumulated in the order encountered.</li> </ul>"},{"location":"Core/Property%20Binding/#error-handling-and-logging","title":"Error handling and logging","text":"<ul> <li>Conversion failures raise an <code>InvalidOperationException</code> internally and are logged through the <code>ILog</code> abstraction. Binding then proceeds to the next property.</li> <li>For collections, if the collection cannot be instantiated, the binder logs a warning and skips population.</li> </ul>"},{"location":"Core/Property%20Binding/#practical-tips","title":"Practical tips","text":"<ul> <li>Prefer explicit <code>DataKeyAttribute</code> on public DTOs, even when keys match property names, to avoid hidden coupling and to document intent.</li> <li>Keep DTOs simple and immutable where practical; for immutable records, bind into a mutable intermediate and project.</li> <li>If you need culture\u2011specific number formats, normalise input to invariant format at source or add a preprocessing pass.</li> <li>For complex transformations, bind strings first and convert with domain\u2011specific logic afterwards.</li> </ul>"},{"location":"Core/Property%20Binding/#reference","title":"Reference","text":"<ul> <li><code>KeyValueReader</code> \u2014 parse a text stream into <code>KeyValueDataRecord</code> items (configurable delimiters and comments)</li> <li><code>KeyValueDataRecord</code> \u2014 holds a <code>Key</code> and a <code>Value</code> string</li> <li><code>DataKeyAttribute</code> \u2014 decorate properties with a <code>Keyword</code> and optional <code>Sequence</code></li> <li><code>PropertyBinder</code></li> <li><code>TOut BindProperties&lt;TOut&gt;(IEnumerable&lt;KeyValueDataRecord&gt;) where TOut : new()</code></li> </ul> <p>See also - Diagnostics and Logging - Async Helpers - Finite State Machine</p>"},{"location":"Core/SemanticVersion/","title":"SemanticVersion","text":"<p>Encapsulates parsing, validation, display formatting, equality, and sorting of SemVer strings. Pre-release and build metadata are handled per SemVer 2.0.0 rules.</p> <ul> <li>Parse: <code>new SemanticVersion(\"1.0.0-alpha.1+meta\")</code></li> <li>Validate: <code>SemanticVersion.IsValid(\"1.0.0\")</code></li> <li>Compare/sort: compares major/minor/patch; pre-releases sort before releases; numeric identifiers sort numerically.</li> </ul> <p>Examples (from specifications): - <code>new(\"1.0.1-alpha.9\") &lt; new(\"1.0.1-alpha.10\")</code> - Build metadata is ignored for equality.</p>"},{"location":"Core/String%20Extensions/","title":"String extensions","text":"<p>Helpers for common string manipulation tasks: filtering characters, extracting head/tail segments, trimming from either end, and rendering strings as hexadecimal. All methods are extension methods on <code>string</code> and return new strings (do not mutate the original).</p> <p>See also - ASCII Mnemonic Expansion \u2014 show control characters as mnemonics (e.g., \\&lt;CR&gt;)</p>"},{"location":"Core/String%20Extensions/#clean-remove-unwanted-characters","title":"Clean: remove unwanted characters","text":"<p>Removes all characters that appear in the supplied <code>clean</code> set and preserves the rest.</p> <pre><code>var source = \"A-B_C\";\nvar cleaned = source.Clean(\"-_\");   // \"ABC\"\n</code></pre> <p>Notes - If <code>source</code> is <code>null</code> or empty, returns <code>string.Empty</code>. - If <code>clean</code> is <code>null</code> or empty, returns <code>source</code> unchanged. - Complexity is O(n \u00d7 m) where n is the source length and m is <code>clean.Length</code>. A HashSet can be faster when <code>clean</code> is very large, but for typical small sets the simple approach is competitive.</p>"},{"location":"Core/String%20Extensions/#keep-keep-only-wanted-characters","title":"Keep: keep only wanted characters","text":"<p>The inverse of Clean. Keeps only characters that appear in the supplied <code>keep</code> set and removes all others.</p> <pre><code>var digits = \"a1b2c3\".Keep(\"0123456789\"); // \"123\"\n</code></pre> <p>Notes - If <code>source</code> is <code>null</code> or empty, returns <code>string.Empty</code>.</p>"},{"location":"Core/String%20Extensions/#head-take-the-first-n-characters","title":"Head: take the first N characters","text":"<p>Returns the first <code>length</code> characters of the string.</p> <pre><code>\"abcdef\".Head(3);     // \"abc\"\n</code></pre> <p>Exceptions - <code>ArgumentNullException</code> if <code>source</code> is <code>null</code>. - <code>ArgumentOutOfRangeException</code> if <code>length</code> &lt; 0 or <code>length</code> &gt; <code>source.Length</code>.</p>"},{"location":"Core/String%20Extensions/#tail-take-the-last-n-characters","title":"Tail: take the last N characters","text":"<p>Returns the last <code>length</code> characters of the string.</p> <pre><code>\"abcdef\".Tail(2);     // \"ef\"\n</code></pre> <p>Exceptions - <code>ArgumentOutOfRangeException</code> if <code>length</code> &gt; <code>source.Length</code>.</p>"},{"location":"Core/String%20Extensions/#removehead-drop-n-characters-from-the-start","title":"RemoveHead: drop N characters from the start","text":"<p>Removes <code>length</code> characters from the start; returns the remainder.</p> <pre><code>\"abcdef\".RemoveHead(2);   // \"cdef\"\n</code></pre> <p>Notes - If <code>length</code> &lt; 1, returns <code>source</code> unchanged. - If <code>length</code> exceeds the source length, <code>Tail()</code> will throw; ensure the value is within range if you do not want an exception.</p>"},{"location":"Core/String%20Extensions/#removetail-drop-n-characters-from-the-end","title":"RemoveTail: drop N characters from the end","text":"<p>Removes <code>length</code> characters from the end; returns the remainder.</p> <pre><code>\"abcdef\".RemoveTail(2);   // \"abcd\"\n</code></pre> <p>Notes - If <code>length</code> &lt; 1, returns <code>source</code> unchanged. - If <code>length</code> exceeds the source length, <code>Head()</code> will throw; ensure the value is within range if you do not want an exception.</p>"},{"location":"Core/String%20Extensions/#tohex-visualise-character-codes","title":"ToHex: visualise character codes","text":"<p>Renders each character\u2019s numeric value in lower\u2011case hexadecimal, surrounded by braces.</p> <pre><code>\"Az\".ToHex();   // \"{41, 7a}\"\n</code></pre> <p>Notes - Useful for diagnostics and debugger output when inspecting non\u2011printable characters or code points.</p>"},{"location":"Core/String%20Extensions/#read-lines-helpers-related","title":"Read lines helpers (related)","text":"<p>There is a companion set of helpers for splitting a string or stream into lines without allocating the entire array up front.</p> <pre><code>// From a string\nforeach (var line in bigText.GetLines()) { /* ... */ }\n\n// From a stream\nawait using var fs = File.OpenRead(path);\nforeach (var line in fs.GetLines()) { /* ... */ }\n</code></pre> <p>Rules - A line ends at CR (0x0D), LF (0x0A), CRLF, <code>Environment.NewLine</code>, or end\u2011of\u2011input; terminators are not included in the returned lines.</p> <p>See also - ASCII Mnemonic Expansion</p>"},{"location":"Logging/NLog%20Adapter/","title":"NLog adapter","text":"<p>An implementation of the logging abstraction (<code>ILog</code>/<code>IFluentLogBuilder</code>) that targets NLog as the back\u2011end. It maps fluent builder calls to NLog\u2019s <code>LogEventInfo</code>, supports semantic properties, and integrates cleanly with NLog targets including Seq.</p> <ul> <li>Package: TA.Utils.Logging.Nlog</li> <li>Classes: <code>LoggingService</code>, <code>LogBuilder</code>, <code>LogServiceOptions</code></li> </ul>"},{"location":"Logging/NLog%20Adapter/#quick-start","title":"Quick start","text":"<pre><code>using TA.Utils.Logging.NLog;\n\nvar options = LogServiceOptions.DefaultOptions\n    .UseVerbosity()\n    .CustomSeverityPropertyName(\"CustomLevel\");\n\nILog log = new LoggingService(options)\n    .WithAmbientProperty(\"CorrelationId\", Guid.NewGuid());\n\nlog.Info().Message(\"Hello {who}\").Property(\"who\", \"world\").Write();\nlog.Level(\"Important\").Message(\"This is important\").Write();\n</code></pre>"},{"location":"Logging/NLog%20Adapter/#verbosity-and-custom-levels","title":"Verbosity and custom levels","text":"<ul> <li>UseVerbosity(propertyName = \"verbosity\")</li> <li>Adds a numeric verbosity property to each entry when you pass the number to the severity method (e.g., <code>Info(2)</code>).</li> <li>CustomSeverityPropertyName(name = \"CustomLevel\")</li> <li>The custom severity property used when you call <code>log.Level(\"Name\")</code>.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#seq-target-mapping-example","title":"Seq target mapping example","text":"<p>To use custom levels with Seq, configure the Seq target to take its level from the custom property when present:</p> <pre><code>&lt;target xsi:type=\"Seq\" name=\"seq\"\n        serverUrl=\"http://your-server-url:5341\"\n        apiKey=\"your-seq-api-key\"\n        seqLevel=\"${event-properties:CustomLevel:whenEmpty=${level}}\" /&gt;\n</code></pre>"},{"location":"Logging/NLog%20Adapter/#logger-names-and-ambient-properties","title":"Logger names and ambient properties","text":"<ul> <li><code>WithName(\"Source\")</code> sets the logger name, which NLog can use for routing and filtering (e.g., <code>${logger}</code> in layouts).</li> <li><code>WithAmbientProperty(\"name\", value)</code> adds a property to all subsequent entries; useful for correlation IDs, component, tenant, etc.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#message-templates-and-properties","title":"Message templates and properties","text":"<ul> <li>Use either indexed placeholders (<code>{0}</code>) or named placeholders (<code>{name}</code>); named placeholders are recommended for semantic logging.</li> <li>Attach additional properties explicitly via <code>.Property(\"name\", value)</code> or <code>.Properties(dict)</code>.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#shutdown","title":"Shutdown","text":"<ul> <li>Call <code>log.Shutdown()</code> or rely on NLog\u2019s <code>AutoShutdown = true</code> set by the adapter type initialiser.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If a property name collides, the adapter auto\u2011deconflicts by suffixing a number (e.g., <code>property</code>, <code>property2</code>).</li> <li>Ensure <code>IsEnabled(Level)</code> is true for the chosen level; otherwise <code>.Write()</code> is a no\u2011op.</li> </ul> <p>See also - Diagnostics and Logging - Console logger (Diagnostics) - ASCII Mnemonic Expansion</p>"}]}