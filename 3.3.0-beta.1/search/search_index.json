{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TA.Utilities Overview","text":"<p>This library represents a collection of classes factored out of our production projects that we found were being used over and over again. Rather than re\u2011using the code at source level, it is collected together in this package as a general\u2011purpose reusable library and made freely available for you to use at no cost and with no obligation. The only stipulation is that you cannot sue the author or Timtek Systems Limited if anything bad happens as a result of you using the code. It is up to you to determine suitability for your purpose.</p>"},{"location":"#software-reuse-at-the-object-code-level","title":"Software re\u2011use at the object code level","text":"<p>This was always the promise of object\u2011oriented design, but it was not until the advent of NuGet and its widespread adoption that this became a practical reality. It is easy to overlook the impact of NuGet, as it seems so obvious and natural once you have used it.</p> <p>\"Dependency management is the key challenge in software at every scale.\" \u2014 possibly attributed to Donald Knuth, The Art of Computer Programming</p> <p>NuGet has essentially solved a large chunk of the dependency management problem. At Timtek Systems, we use NuGet as a key component in our software design strategy. We publish our open\u2011source code on a public MyGet feed. We push both prerelease and release versions to MyGet. When we make an official release, we promote that package from MyGet to NuGet. You can consume our packages from either location, but if you want betas and release candidates, you will need to use our MyGet feed.</p>"},{"location":"#licensing","title":"Licensing","text":"<p>This software is released under the Tigra MIT Licence, which (in summary) means: \"Anyone can do anything at all with this software without limitation, but it is not our fault if anything goes wrong\".</p> <p>Our philosophy of open source is to give wholeheartedly with no strings attached. We have no time for \u201ccopyleft\u201d licences which we find irksome. So here it is, for you to use however you like, no strings attached.</p> <p>I tend to use \u201cwe\u201d and \u201cour\u201d when talking about the company, but Timtek Systems Limited is a one\u2011man operation run by me, Tim Long. I hope you find the software useful, and if you feel that my efforts are worth supporting, then it would make my day if you would buy me some coffee. I also would not mind you giving us a mention, if you feel you are able to, as it helps the company grow. Donations and mentions really make a difference, so please think about it and do what you can.</p> <p>If you are a company and need some work done, then consider hiring me as a freelance developer. I have decades of experience in product design, firmware development for embedded systems and PC driver and software development. I am a professional; I believe in doing what is right, not what is expedient, and I support my software.</p> <p>See also: Release Notes.</p>"},{"location":"About%20GitVersion/","title":"GitVersion: benefits over manual versioning","text":"<p>GitVersion automates semantic versioning by deriving a version from your Git history and branch conventions. Compared to hand\u2011maintained versions, it provides consistency, removes busywork, and eliminates whole classes of release mistakes.</p> <p>Key benefits - Zero manual bumps   - No more \u201cremember to bump\u201d PRs; the version is computed from commits/branches/tags. - Consistent SemVer across all builds   - CI, local dev, and release builds resolve the same version for the same commit. - First\u2011class pre\u2011releases without ad\u2011hoc suffixes   - Branches map to pre\u2011release channels (e.g., develop \u2192 alpha, release/* \u2192 beta) with incremental identifiers. - Traceability and provenance   - InformationalVersion embeds branch and commit (e.g., +Branch.develop.Sha.XXXX), making binaries self\u2011describing. - Works with Git Flow   - Feature \u2192 pre\u2011release while developing; release branches stabilize as beta; tagging on main/master promotes to a stable version. - Deterministic packages and assemblies   - Packages built from the same commit get the same version, avoiding \u201cmystery rebuilds\u201d that overwrite artifacts. - Cleaner PRs and histories   - No noise commits solely to bump versions; reduces merge conflicts in project files. - Policy as configuration   - Version rules live in configuration rather than tribal knowledge; easy to review and change as a team policy.</p> <p>How it helps in this repository - We already reference GitVersion.MsBuild in the packable libraries, so assemblies and NuGet packages receive the computed version automatically at build time. - The docs site deployments also use the GitVersion SemVer as the mike version for develop and release/* builds, so your published documentation versions align with your code versions. - Release tagging uses the raw semantic tag (no leading \u201cv\u201d), which becomes the published stable version and moves the latest alias in documentation.</p> <p>Manual versioning pitfalls avoided - Forgotten or inconsistent bumps between projects/solutions in a repo. - Conflicting edits to the same version fields during parallel work/merges. - Drift between \u201cAbout\u201d dialogs, assembly attributes, package versions, and documentation. - Ambiguous nightly/CI builds where two different commits share the same nominal version.</p> <p>See also - Versioning (GitVersion + SemVer)</p>"},{"location":"Diagnostics%20and%20Logging/","title":"Diagnostics and Logging","text":""},{"location":"Diagnostics%20and%20Logging/#consoleloggerservice-implements-ilog","title":"<code>ConsoleLoggerService</code> implements <code>ILog</code>","text":"<p>One step up from the <code>DegenerateLoggerService</code>, enables easy rudimentatary logging to the console without depending on any logging framework or configurations files. This is meant to be a light-weight stop-gap logging solution for projects that never get large enough to warrant full structured logging.</p> <p><code>ConsoleLoggerService</code> is fully compatible with and interchangeable with any logging back-end built on the <code>ILog</code> interface. The Liskov Subsitution Principle is observed, so it remains easy to switch logging back-ends just by changing a binding in your IOC container. Start yoru console app with a <code>ConsoleLoggingService</code>, then when it becomes a limitation, simply plug-in a full-blown logger such as the NLog implementation founf in <code>TA.Utils.Logging.NLog</code>.</p>"},{"location":"Diagnostics%20and%20Logging/#logging","title":"Logging","text":"<p>Logging is a big deal. It is an essential part of debugging during development, but can also be really useful or even essential in production. It needs to be easy to use, or developer's won't use it. It needs to not re-invent any wheels. There are plenty of good logging services out there.</p> <p>Our approach to logging is this: 1. No dependency on any particular logging framework.    We define an abstract interface that can be adapted to any back-end logging engine. 2. Follow the KISS principle: \"Keep it simple, stupid\".    Logging should be easy enough that people will use it, but have enough flexibility to be useful in the real world.</p> <p>We provide an abstract fluent builder pattern for easily constructing log entries and which provides an extensibility point for creating extension methods.</p> <p>Our fluent builder interface supports semantic logging which enables the creation of rich logging data.</p> <p>Item (1) notwithstanding, we have based our fluent builder API loosely on the one used by NLog. We think it is the best balance of simplicity and flexibility. However, we do not depend on NLog and have made our own abstract interfaces that can target any logging framework.</p> <p>The <code>TA.Utils.Core.Diagnostics</code> namespace defines a pair of interfaces, <code>ILog</code> and <code>IFluentLogBuilder</code>, that define an abstract logging service which does not depend on any particular back-end.</p> <p>Libraries can perform logging through these interfaces without ever taking a dependency on any logging imnplementation. The actual implementation can be injected at runtime, typically in a constructor parameter. The policy decision about which logging engine to use can be taken in the top level composition root of the application.</p> <p>The fluent interface defined in <code>IFluentLogBuilder</code> was modeled on the NLog fluent interface, so it is a very natural fit. However, the interface has enough flexibility to adapt to other logging backends without too much trouble.]</p> <p>A null implementation is provided in <code>DegenerateLoggerService</code> and <code>DegenerateLogBuilder</code>. The two classes do essentially nothing and produce no output; they are a data sink. Libraries can choose to use this as their default logging implementation, which is easier than checking whether the logger is null every time it is used.</p> <p><pre><code>public class MyClassThatUsesLogging\n{\n    private ILog Log;\n\n    // Construct an instance and optionally inject the logging service implementation.\n    public MyClassThatUsesLogging(ILog logService = null)\n    {\n        // Use the supplied logging service, or fall back to the degenerate logger.\n        this.Log = logService ?? new DegenerateLoggerService();\n    }\n\n    public void MethodThatGeneratesLogEntries()\n    {\n        Log.Info()\n            .Message(\"I am loosely coupled. I do not depend on any logging back-end.\")\n            .Write();\n    }\n}\n</code></pre> The interface supports semantic logging. You can use a simple format string like so: <pre><code>log.Info().Message(\"Sending data {0}\", data).Write();\nlog.Error().Message(\"Exception {0} occurred with error code {1}\", ex.Message, errorCode).Write();\n</code></pre> But this leaves useful information on the table. Extra rich information can be included like so: <pre><code>log.Info().Message(\"Sending data {data}\", data).Write();\nlog.Error()\n    .Message(\"Exception {exception} occurred with error code {error}\")\n    .Property(\"exception\", ex.Message)\n    .Property(\"error\", errorCode)\n    .Exception(ex)\n    .Write();\n</code></pre> In both statements, we are adding property-value pairs to the log. In the first <code>Log.Info()</code> statement this is implicit, whereas in the <code>Log.Error()</code> statement it is made explicit. This extra information may or may not be used by the log renderer, but if its not there then it can't be used! So if in doubt, include extra information where it is appropriate.</p> <p>Again, this feature set is native to NLog so makes for a very lightweight adaptor. When developing adaptors for other logging frameworks, every attempt shouldbe made to preserve as much of the information as possible.</p>"},{"location":"Diagnostics%20and%20Logging/#two-stage-approach-to-logging","title":"Two-stage Approach to Logging","text":"<p>Think of logging as occurring in two distinct stages.</p> <ol> <li>You build the log entry using <code>IFluentLogBuilder</code>, adding all of the relevant information as Properties of the log entry.</li> <li>You send the log entry to the back-end to be rendered on one or more Targets.</li> </ol> <p>Each target may use none, some or all of the information you provided and it may even augment it with additional metadata. As a library developer, you shouldn't be concerned with how the entry will be rendered, stored or how it will be formatted. You should concentrate only on including as much relevant information as is appropriate in your log entries.</p> <p>Multiple targets may be in use and different targets will produce different output from the exact same log entry. For example:</p> <ul> <li>A file target may include a timestamp and perform log file rotation so that a new file is created each day.</li> <li>A debug output stream may include the name of the class where the log entry originated and print only the message portion.</li> <li>A console logger may write different lines in different colours accoring to the severity level.</li> <li>A syslog target may include the host name of the originating computer.</li> <li>A NoSQL database renderer may write out all of the properties as a JSON document.</li> </ul> <p>In most cases, the way in which log data is ultimately rendered is outside of application control. Typically, a configuration file is used. The configuration file may be added or changed post-deployment. As a library developer, you must accept that you have little to no control over this. Just concentrate on including appropriate and useful information and don't think about formatting or storage.</p>"},{"location":"Diagnostics%20and%20Logging/#a-note-on-semantic-logging","title":"A Note on Semantic Logging","text":"<p>If you have always thought about logging as <code>Console.WriteLine()</code> statements, then you have probably focussed on formatting your output and given little thought to the content. You might struggle to see the point of semantic logging and you might be due for a paradigm shift. Forget about how your log output looks and focus on what data it contains. Your responsibility as the log entry creator is to include as much relevant data as possible. Assume that formatting (rendering) and filtering will be done elsewhere and is outside your control.</p> <p>How useful would it be, for example, if when you logged an exception, it included all the exception metadata, any inner exceptions, and a full stack trace? You might struggle to achieve this using <code>Console.WriteLine()</code>. In our paradigm, that is as simple as adding <code>.Exception(ex)</code> to your log builder statement.</p> <p>Having done that, you might think \"so what?\". The log file produced still only shows the exception message, so what was the point? We struggled with this oursleves. You put the data in, but it doesn't easily come out in a meaningful way. Then one day we were \"red-pilled\" by Seq. We discovered the truth that flat files are an inadequate solution for rendering log output.</p> <p>We had our \"Aha!\" moment the first time we logged and exception to Seq and were able to view the full stack trace. There is so much more to Seq, but that was the moment we understood semantic logging. Seq unlocks the full usefulness of all that data and will change the way you write log entries. Once you see the truth, Neo, you cannot go back. You cannot \"unsee\" Seq. We realised that merely by changing a configuration file, i.e. with zero code impact, we could send our log entries across the network to a log server that could store them in a SQL database. We could then use our web browser to log into that server to view the log data, in real time, and be able to view, search, filter and query based on the full data that we put into our log entries.</p> <p>Seq can be used with our logging abstraction and the NLog adapter, and using the NLog.Targets.Seq NuGet package. You can then configure a Seq target for NLog in your NLog.config file (there is no special code needed).</p>"},{"location":"Diagnostics%20and%20Logging/#seq-special-considerations","title":"Seq Special Considerations","text":"<p>We highly recommend Seq. It's free for a single user and can be set up in a few moments using Docker. This section contains some of our explorations with Seq.</p>"},{"location":"Diagnostics%20and%20Logging/#tldr","title":"TL;DR","text":"<ul> <li>Add and ambient property called <code>CorrelationId</code> to all log entries and set it to a new <code>Guid</code> each time the program starts. This helps you find all the log entries relating to a particular run of the program.</li> <li>Register a Last Chance Exception Handler as soon as your program starts; this will let you catch and log any program crashes as they happen. Have your handler log the exception and display a message to the user with the <code>CorrelationId</code> that they should use in any bug reports. This will make it trivial to find the error in the logs.</li> <li>When reporting a <code>CorrelationId</code> to the user, you can use just the last few digits (we use 6) of the <code>CorrelationId</code>, this is usually enough to uniquely identify a log session.</li> <li>Use dependency injection and have your IOC container create loggers for injection into class constructors.</li> </ul> <p>This method may be useful. It was written for use with Ninject, but you can distill out the approach  of looking at the stack frame to work out the calling type and set the logger name from that. <pre><code>/// &lt;summary&gt;\n///     Get an instance of a service from the dependency injection kernel.\n///     Special handling for logging services.\n/// &lt;/summary&gt;\n/// &lt;typeparam name=\"TService\"&gt;The type of service requested.&lt;/typeparam&gt;\n/// &lt;returns&gt;An instance of the requested service.&lt;/returns&gt;\npublic static TService Get&lt;TService&gt;()\n{\n   if (typeof(ILog).IsAssignableFrom(typeof(TService)))\n   {\n       // Special handling for request for ILog.\n       // Try to determine the calling type by examining the stack, and pass it to the kernel as a binding parameter.\n       var callerStackFrame = new StackFrame(1);\n       var callingMethod = callerStackFrame.GetMethod();\n       // MethodBase.ReflectedType is more reliable than the direct Type property and less likely to return an \"un-utterable name\".\n       var callerType = callingMethod.ReflectedType;\n       var callerTypeName = callerType?.Name ?? string.Empty;\n       if (!string.IsNullOrEmpty(callerTypeName))\n       {\n           var logServiceNameParameter = new Parameter(LogSourceParameterName, callerTypeName, false);\n           return Kernel.Get&lt;TService&gt;(logServiceNameParameter);\n       }\n   }\n\n   // For all other requests, simply request the type from the DI kernel.\n    return Kernel.Get&lt;TService&gt;();\n}\n</code></pre></p>"},{"location":"Diagnostics%20and%20Logging/#log-correlation","title":"Log Correlation","text":"<p>We use a global static readonly GUID called something like <code>CorrelationId</code>. We initialize this with a new <code>Guid</code> as early as possible in the program execution, usually in a static initializer, so that it has a new value for each run of the program. We then add this to every instance of <code>ILog</code> as an Ambient Property.</p> <p>This way, every log entry we write contains a <code>CorrelationId</code> value which is unique for each run of the program. In Seq, you can Expand a log entry, find the <code>CorrelationId</code> property, and click the checkmark next to it, then select \"Find\". This will find all the log entries for one run of the program.</p> <p></p>"},{"location":"Diagnostics%20and%20Logging/#custom-severity-levels","title":"Custom Severity Levels","text":"<p>NLog has fice severity levels: <code>Trace</code>, <code>Debug</code>, <code>Info</code>, <code>Warning</code>, <code>Error</code> and a pseudo-level <code>Fatal</code> which actually causes the program to exit, so can't really be used as a normal severity level.</p> <p>We find this a bit limiting and would like to be able to create our own levels, such as <code>Note</code> and <code>Important</code>.</p> <p>The <code>NLog.Targets.Seq</code> logging target has support for this, and we also support it in our <code>ILog</code> interface via the <code>ILog.Level(string levelName)</code> method.</p> <p>The way this works is to create an additional log event property, by default named \"CustomLevel\", containing the level name. The Seq target then uses this property as the level when it posts the data to the Seq server. If the default property name is no good for some reason, it can be changed using a <code>LogServiceOptions</code> instance and setting <code>LogServiceOptions.CustomSeverityPropertyName</code> property to the preferred name, like so: <pre><code>var options = LogServiceOptions.DefaultOptions.CustomSeverityPropertyName(\"SeqLevel\");\nvar log = new LoggingService(options);\n</code></pre> A small bit of configuration is needed to wire this up, in the Seq target in the <code>NLog.config</code> file, like so: <pre><code>      \\\\&lt;target xsi:type=\"Seq\" name=\"seq\" \n      serverUrl=\"http://your-server-url:5341\"\n      apiKey=\"your-seq-api-key\"\n      seqLevel=\"${event-properties:CustomLevel:whenEmpty=${level}}\"\\\\&gt;\n</code></pre> The magic is in <code>seqLevel=\"${event-properties:CustomLevel:whenEmpty=${level}}</code></p> <p>This uses the value of <code>CustomLevel</code> as the Seq level, unless it is empty or missing, in which case it defaults to the NLog level.</p> <p>In targets other than Seq, this will just appear as yet another log event property.</p>"},{"location":"Home/","title":"Home (vault index)","text":"<p>This page provides a table of contents for easy navigation while editing in Obsidian.</p> <ul> <li>Overview</li> <li>[[Overview|Project Overview]]</li> <li>Versioning (GitVersion + SemVer)</li> <li>Why GitVersion (automation vs. manual)</li> <li>Diagnostics and Logging</li> <li>Diagnostics and Logging</li> <li>Core Utilities</li> <li>SemanticVersion</li> <li>Maybe\\&lt;T&gt;</li> <li>Octet</li> <li>Code Contracts</li> <li>Display Equivalent</li> <li>ASCII Mnemonic Expansion</li> <li>Async Helpers</li> <li>Property Binding</li> <li>String extensions</li> <li>Math extensions</li> <li>Console logger (Diagnostics)</li> <li>Finite State Machine</li> <li>Logging</li> <li>NLog adapter</li> <li>Release Notes</li> <li>Release Notes</li> <li>Areas for Improvement</li> <li>FSM SOLID analysis for Finite State Machine</li> </ul>"},{"location":"Release%20Notes/","title":"Release Notes","text":"<p>3.1.0 - Documentation and site   - Migrated monolithic README into a structured Obsidian vault; added topic pages for Core utilities (e.g., String Extensions, Math, Property Binding, FSM) and logging (Console, NLog adapter).   - Published versioned documentation to GitHub Pages using MkDocs + Material + mike with alpha/beta/latest aliases.   - Enabled colourful syntax highlighting for code blocks (pymdown-extensions highlight + superfences). - Build/CI for docs   - Docs workflow uses GitVersion SemVer as the mike version for develop/release/* branches.   - Fixed version switcher by explicitly setting <code>site_url</code> so <code>versions.json</code> is resolved from site root.</p> <p>3.0.0 - Logging   - Added <code>ReentrancyGuardLog</code>, a decorator that prevents re\u2011entrant writes on the current async\u2011flow to avoid recursive logging loops. - Tests/targets   - Specifications target .NET 8.0 in addition to .NET Framework 4.8.</p> <p>2.10.0  - Improved how code contracts handle recording the contract data in the <code>CodeContractViolationException</code>.  - Added the ability to configure logging levels in ConsoleLoggerOptions. The default is to log everything.    - Specific severity levels can be included using <code>RenderSeverityLevels()</code>. Once configured with any value, the default no longer applies so all levels to be logged must be included.    - Specific levels may also be ignored using <code>IgnoreSeverityLevels()</code>. The ignore list takes precedence over the include list.</p> <p>2.9.0 - Added Code Contract assertions that can be used for enforcing code contracts at runtime. Contract failures result in a <code>CodeContractViolationException</code> being thrown. The exception records the value being tested, any predicate expression that was used in the test, and the message that was passed to the assertion method. Any occurrence of a <code>CodeContractViolationException</code> should be treated as an unambiguous bug in the code and not caught or handled, except to write it out to a log.</p> <p>2.8.1 - Fixed an issue that caused a custom severity property name option to be ignored.</p> <p>2.8.0 - Fixed a formatting bug in <code>Octet.ToString()</code>.</p> <p>2.7.0 - Added support for custom severity levels in the <code>ILog</code> abstraction and NLog implementation. - Used the \u201cofficial\u201d regular expression to validate semantic version strings. Note: some strings that were previously accepted, such as \u201c01.02.03\u201d, will no longer be accepted as valid.</p>"},{"location":"Versioning/","title":"Versioning","text":"<p>Timtek has settled on an automated versioning strategy based on Semantic Versioning 2.0.0 and About GitVersion.</p> <p>We give all of our software a semantic version, which we display to the user in the About box and write out to log files on startup. We use GitVersion to automatically assign a version number to every build (even in Arduino projects). We never manually set the version number, it happens as part of the build process. So we can never forget to \"bump the version\" and we can never forget to set it. Total automation. If you examine one of our log files, you may well find something like this:</p> <p><pre><code>21:16:59.2909|INFO |Server          |Git Commit ID: \"229c1acc4a7bda494f78a8c7cc811c2a4d8e9132\"\n21:16:59.3069|INFO |Server          |Git Short ID: \"229c1ac\"\n21:16:59.3069|INFO |Server          |Commit Date: \"2020-07-11\"\n21:16:59.3069|INFO |Server          |Semantic version: \"0.1.0-alpha.1\"\n21:16:59.3069|INFO |Server          |Full Semantic version: \"0.1.0-alpha.1\"\n21:16:59.3069|INFO |Server          |Build metadata: \"Branch.develop.Sha.229c1acc4a7bda494f78a8c7cc811c2a4d8e9132\"\n21:16:59.3069|INFO |Server          |Informational Version: \"0.1.0-alpha.1+Branch.develop.Sha.229c1acc4a7bda494f78a8c7cc811c2a4d8e9132\"\n</code></pre> There's no mistaking where that build came from.</p>"},{"location":"Versioning/#semanticversion-class","title":"<code>SemanticVersion</code> class","text":"<p>Since we rely heavily on semantic versioning, it is useful to have a class that encapsulates all the rules for parsing, outputting, comparing and sorting semantic versions. That is the function of the <code>SemanticVersion</code> class. With it you can:</p> <ul> <li>Parse a semantic version string;</li> <li>Validate a semantic version string;</li> <li>Format a version for display, logging or printing;</li> <li>Test the equality of two versions using the correct comparison rules;</li> <li>Sort versions using the correct collation rules.</li> </ul>"},{"location":"Versioning/#gitversion-support","title":"GitVersion Support","text":"<p>GitVersion also injects a static class into the assembly containing all the versioning information it computed based on your Git commit history. This information can be a little tricky to get at, because it doesn't exist at compile time so you can't easily reference it. You have to use Reflection to get at it. Our <code>GitVersion</code> class contains static properties for getting your semantic version metadata at runtime. We use it to write the log entries as shown above.</p>"},{"location":"Areas%20for%20Improvement/FSM%20SOLID%20Analysis/","title":"FSM SOLID analysis and recommendations","text":"<p>This document reviews the finite state machine (FSM) design in TA.Utils.Core.StateMachine with respect to the SOLID principles, and proposes pragmatic improvements. It assumes familiarity with Finite State Machine as implemented in this repository.</p> <p>Summary - The design is clean and pragmatic: small, composable abstractions, with a clear split between \"state\" and \"machine\" and sensible use of observability. - The main areas to tighten are: concurrency safety and visibility across threads, transition error handling (especially exceptions from a state\u2019s RunAsync), resource disposal, and API shape.</p> <p>Strengths (per SOLID) - Single Responsibility   - <code>IState</code> encapsulates a state\u2019s lifecycle: enter, run, exit, with a clear cancellation boundary.   - <code>IFiniteStateMachine\\&lt;TState\\&gt;</code> focuses on orchestration and observation (start/stop/transition + observability).   - <code>FiniteStateMachine\\&lt;TState\\&gt;</code> centralises transition sequencing: cancel current, wait, exit, enter, run next. - Open\u2013Closed   - Virtual methods permit extension via subclassing without modifying core code.   - Logging depends on <code>ILog</code> and remains pluggable. - Liskov Substitution   - The <code>IState</code> contract is straightforward; implementations can substitute so long as they honour cancellation and lifecycle hooks. - Interface Segregation   - <code>IState</code> and <code>IFiniteStateMachine\\&lt;TState\\&gt;</code> are small and coherent. - Dependency Inversion   - Depends on abstractions (<code>IState</code>, <code>ILog</code>, <code>IObservable</code>) rather than concrete frameworks.</p> <p>Weaknesses and risks - Scope creep in the core class (SRP pressure)   - <code>FiniteStateMachine\\&lt;TState\\&gt;</code> handles orchestration, concurrency/cancellation, signalling, event publication and logging. This increases the reasons for the class to change. - Limited extension points (OCP pressure)   - No injection point for custom scheduling, transition guards, timeout policies, or exception handling strategies. Subclassing risks invariant breakage. - Invariants are not formalised (LSP risk)   - Transition semantics are not strictly documented; overrides could violate cancellation/ordering guarantees. A public <code>ManualResetEvent</code> leaks an implementation detail a subclass might change. - Interface details   - <code>DisplayName</code> on <code>IState</code> is UI\u2011oriented; some domains may not wish to couple display concerns into the core interface. - API leakage and synchronisation primitive   - Exposing <code>ManualResetEvent</code> couples consumers to a particular synchronisation model; an awaitable API would be a better abstraction. - Concurrency/thread safety   - No explicit locking around <code>CurrentState</code>/<code>currentStateTask</code>/<code>stateCancellation</code>. Concurrent <code>TransitionTo</code> calls can interleave.   - <code>Subject&lt;T&gt;</code> emissions occur on background threads; consumers may incorrectly assume a context. - Error handling of state failures   - Only <code>OperationCanceledException</code> is caught when waiting for the prior state; unexpected exceptions from <code>RunAsync</code> could become unobserved or skip completion signalling. - Resource disposal   - The previous <code>CancellationTokenSource</code> is replaced but never disposed; repeated transitions can leak handles. - Logging responsibility   - Logging inside the core class conflicts with the repository preference for a logging decorator. - Test synchronisation ergonomics   - Exposing <code>ManualResetEvent</code> invites blocking APIs; async/await would be more idiomatic and composable.</p> <p>Recommendations 1) Serialise transitions and protect shared state - Use a private lock or a serial queue to ensure <code>TransitionTo</code> is processed one at a time and to protect <code>CurrentState</code>, <code>currentStateTask</code>, <code>stateCancellation</code> and the <code>stopped</code> flag.</p> <p>2) Dispose the previous <code>CancellationTokenSource</code> - Swap, cancel, and dispose the old CTS to avoid leaking OS handles.</p> <pre><code>// inside CancelCurrentState()\nvar old = Interlocked.Exchange(ref stateCancellation, new CancellationTokenSource());\ntry { old.Cancel(); } catch (ObjectDisposedException) { }\nold.Dispose();\n</code></pre> <p>3) Catch and log all exceptions from state tasks and waits - Ensure the transition path cannot fault and skip completion signalling; log unexpected exceptions at Error and proceed.</p> <pre><code>try\n{\n    currentStateTask?.Wait();\n}\ncatch (OperationCanceledException ex)\n{\n    log.Warn().Exception(ex).Message(\"State cancelled while awaiting completion\").Write();\n}\ncatch (Exception ex)\n{\n    log.Error().Exception(ex).Message(\"Unhandled exception from state RunAsync: {message}\", ex.Message).Write();\n}\n</code></pre> <p>4) Replace <code>ManualResetEvent</code> with an awaitable API - Add <code>TransitionAsync(next, ct)</code> that completes when the new state is fully activated (after <code>OnEnter</code> and <code>RunAsync</code> is scheduled). Retain the event internally for tests if required.</p> <pre><code>public Task TransitionAsync(TState next, CancellationToken ct = default)\n{\n    var tcs = new TaskCompletionSource();\n    TransitionTo(next);\n    Task.Run(() =&gt;\n    {\n        StateChanged.WaitOne();\n        tcs.TrySetResult();\n    }, ct);\n    return tcs.Task;\n}\n</code></pre> <p>5) Introduce extension points (favour composition) - <code>ITransitionScheduler</code> \u2013 how transitions are queued/executed. - <code>IExceptionPolicy</code> \u2013 how to deal with exceptions from <code>OnExit</code>/<code>RunAsync</code> (log, rethrow, transition to fallback). - <code>ITransitionGuard</code> \u2013 optional policy to allow/deny a transition.</p> <p>6) Seal the core class and add a logging decorator - Seal <code>FiniteStateMachine\\&lt;TState\\&gt;</code> to protect invariants. - Move logging into a <code>FiniteStateMachineLoggingDecorator\\&lt;TState\\&gt;</code> that wraps <code>IFiniteStateMachine\\&lt;TState\\&gt;</code> and logs around calls.</p> <p>7) Provide async\u2011first APIs - Add <code>StartAsync</code>, <code>TransitionAsync</code>, <code>StopAsync</code> (with optional timeouts). Keep synchronous counterparts for convenience, but prefer async in usage and examples.</p> <p>8) Document or parameterise the observer context - Clearly document that <code>ObservableStates</code> emits on background threads, or accept an <code>IScheduler</code> to marshal notifications.</p> <p>9) Optional: make state publication replayable - Provide a way for late subscribers to receive the current state immediately (e.g., cache last activation and emit it on subscription).</p> <p>10) Consider decoupling display concerns - Make <code>DisplayName</code> optional or move UI\u2011oriented concerns to a separate optional interface.</p> <p>11) Add transition timeouts and fallbacks - Ensure a misbehaving state that ignores cancellation cannot block shutdown indefinitely; log at Error and move to a safe state after a timeout.</p> <p>12) Extend the test suite for race and failure modes - Add specs for rapid sequential transitions, Stop during a transition, exceptions thrown by <code>RunAsync</code>, and <code>OnExit</code> throwing. Assert that invariants hold and notifications always complete.</p> <p>Expected benefits - Stronger invariants and simpler reasoning about concurrency. - Cleaner API surface (async/await rather than synchronisation primitives). - Alignment with repository preferences (sealed by default; logging via decorator). - Improved testability and resilience, with pluggable policies. - Fewer leaks and unobserved exceptions; more graceful behaviour under failure.</p> <p>Related topics - Finite State Machine - Async Helpers - Diagnostics and Logging</p>"},{"location":"Core/ASCII%20Mnemonic%20Expansion/","title":"ASCII Mnemonic Expansion","text":"<p>When dealing with streams of ASCII-encoded data, it is often helpful to be able to see non-printing and white space characters. This is especially useful when logging. The <code>ExpandAscii()</code> extension method makes this simple. Us <code>string.ExpansAscii()</code> and cahacters such as carriage return, for example, will be rendered as <code>\\&lt;CR\\&gt;</code> instead of causing an ugly line break in your log output.</p> <p><code>ExpandAscii()</code> uses the mnemonics defined in the <code>AsciiSymbols</code> enumerated type.</p>"},{"location":"Core/Async%20Helpers/","title":"Asynchrony and Threading","text":""},{"location":"Core/Async%20Helpers/#configureawait","title":"ConfigureAwait","text":"<p>There is an extension method in .NET used to configure awaitable tasks, called <code>ConfigureAwait(bool)</code>. The method affects how the task awaiter schedules its continuation. With <code>ConfigureAwait(true)</code> the task continues on the current synchronization context. That usually means on the same thread, and is particularly relevant when the awaiter is a user interface thread. Conversely, <code>ConfigureAwait(false)</code> means that continuation can happen on any thread,  and typically that will be a thread pool worker thread. The implications are quite profound, especially for apartment-threaded GUI applications such as WinForms or WPF.  Consider the following method: <pre><code>public async Task SomeMethod()\n    {\n    Console.WriteLine(\"Starting on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    await Task.Delay(1000).ConfigureAwait(false);\n    Console.WriteLine(\"Continuing on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    }\n</code></pre> When you run this, you may get something like</p> <p>Starting on thread 14 Continuing on thread 11</p> <p>But it is not at all ovious how <code>ConfigureAwait()</code> should be used. What if you don't specifiy? Is the await configured or unconfigured? Does <code>ConfigureAwait(false)</code> mean you don't want to configure it, or that you want to configure it not to do something? It's just horrible. You can't read the code and instantly understand what it does, and that violates the Principle of Least Astonishment.</p> <p>So we made some extension methods that essentially do the same thing, but make more sense. Our aync method now becomes: <pre><code>public async Task SomeMethod()\n    {\n    Console.WriteLine(\"Starting on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    await Task.Delay(1000).ContinueOnAnyThread();\n    Console.WriteLine(\"Continuing on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    }\n</code></pre> and we get</p> <p>Starting on thread 15 Continuing on thread 13</p> <p>Alternatively: <pre><code>public async Task SomeMethod()\n    {\n    Console.WriteLine(\"Starting on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    await Task.Delay(1000).ContinueInCurrentContext();\n    Console.WriteLine(\"Continuing on thread {0}\", Thread.CurrentThread.ManagedThreadId);\n    }\n</code></pre> The await captures the current <code>SynchronizationContext</code> and uses it to schedule the continuation. What happens next depends on the application model and how it implements <code>SynchronizationContext</code>. For a user interface application, the UI generally runs in a Single Threaded Apartment (STA thread). In this model, asynchronous operations are posted to the message queue of the STA thread. The continuation will then happen on the UI thread once the thread is idle and the message pump runs. In a free-threaded application model such as a console application, the continuation will likely still happen on a different thread.</p> <p>Here you can see the danger of this option. If the continuation is queued in the message queue waiting for messages to be pumped, but the UI is blocked waiting for the task to complete, then the continuation may never get to run. The task is prevented from completing and we are in deadlock. Therefore, best practice for library writers is to always use <code>ContinueOnAnyThread()</code>.</p>"},{"location":"Core/Async%20Helpers/#cancel-culture","title":"Cancel Culture","text":"<p>One final extension method is <code>Task.WithCancellation(token)</code>. This takes a task that is not cancellable and wraps it in a cancellable task. Awaiters can then wait on the cancellable wrapper and will get to run if the wrapper is cancelled. Note that this doesn't stop the original task from running and it may still run to completion, but its result will be discarded as there should be nothing awaiting the result.</p>"},{"location":"Core/Code%20Contracts/","title":"Code Contract Assertions","text":"<p>A set of extension methods for making runtime assertions that can help to catch code contract violations.</p> <p><pre><code>void AddUserToDatabase(User user)\n{\n    // Check that the user is not null and that the age is greater than 18.\n    user.ContractAssertNotNull();\n    user.Age.ContractAssert(p =&gt; p &gt; 18, \"Age must be greater than 18\");\n}\n</code></pre> Any assertion failure will result in a <code>ContractViolationException</code> being thrown. It is recommended not to catch these exceptions, but to let them bubble up to the application root where they can be logged and the application terminated cleanly. A <code>ContractViolationException</code> is an unequivocal indication of a bug in the code, so it should never be caught and handled. It is a failure of the code contract, not a runtime error that can be recovered from.</p>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/","title":"Console logger (Diagnostics)","text":"<p>A minimal, dependency\u2011free console implementation of the logging abstraction, useful for small tools and early development. It implements <code>ILog</code>/<code>IFluentLogBuilder</code> and writes entries to the console with optional property rendering and verbosity support.</p> <ul> <li>Class: <code>ConsoleLoggerService</code></li> <li>Builder: <code>ConsoleLogBuilder</code></li> <li>Options: <code>ConsoleLoggerOptions</code></li> </ul>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#quick-start","title":"Quick start","text":"<pre><code>var options = ConsoleLoggerOptions.DefaultOptions\n    .UseVerbosity()\n    .RenderProperties(true)\n    .RenderSeverityLevels(\"Info\", \"Warn\", \"Error\");\n\nILog log = new ConsoleLoggerService(options);\nlog.Info(2).Message(\"Hello {who}\").Property(\"who\", \"world\").Write();\n</code></pre>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#options","title":"Options","text":"<ul> <li>UseVerbosity(propertyName = \"verbosity\")</li> <li>Adds a property to each entry (default name \"verbosity\"). The number passed to the severity method is recorded.</li> <li>Example: <code>log.Info(2)</code> \u2192 property <code>{ verbosity: 2 }</code>.</li> <li>RenderProperties(enable = true)</li> <li>Controls whether the property bag is emitted to the console. Enabled by default.</li> <li>RenderAllSeverityLevels()</li> <li>Resets filtering so that all severities are shown (the default unless modified).</li> <li>RenderSeverityLevels(params string[] levels)</li> <li>An allow\u2011list for severities to render (e.g., \"Info\", \"Warn\", \"Error\"). Removing a level implicitly overrides previous includes.</li> <li>IgnoreSeverityLevels(params string[] levels)</li> <li>A deny\u2011list; takes precedence over the allow\u2011list.</li> </ul> <p>Behaviour - If Ignore includes a level, it is not rendered. - If Render list is empty, all levels are rendered by default.</p>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#ambient-properties-and-names","title":"Ambient properties and names","text":"<ul> <li><code>WithAmbientProperty(name, value)</code> adds a property to all subsequent entries.</li> <li><code>WithName(source)</code> sets the logger\u2019s source name for downstream filtering or routing.</li> </ul>"},{"location":"Core/Console%20Logger%20%28Diagnostics%29/#reentrancy-guard-optional","title":"Re\u2011entrancy guard (optional)","text":"<p>To prevent recursive log writes (e.g., logging during serialisation) you can wrap any logger in the guard decorator:</p> <pre><code>ILog baseLog = new ConsoleLoggerService();\nILog log = new ReentrancyGuardLog(baseLog);\n</code></pre> <p>If a write is attempted while another write is in progress on the same async\u2011flow, the nested write is dropped.</p> <p>See also - Diagnostics and Logging - ASCII Mnemonic Expansion</p>"},{"location":"Core/Display%20Equivalent/","title":"Display Equivalence for Enumerated Types","text":"<p>The <code>[DisplayEquivalent(\"text\")]</code> Attribute works with the <code>EnumExtensions.DisplayEquivalent()</code> extension method. This can be useful for building drop-down lists and Combo box contents for enumerated types, or anywhere that a human-readable version of an Enum member name is needed. You can always get the equivalent human-readable display text for an enumerated value using <code>value.DisplayEquivalent()</code>. This will return the display text if it has been set, or the name of the enum value otherwise. Set the display text by dropping a <code>[DisplayEquivalent(\"text\")]</code> attribute on each field of the enum.</p> <pre><code>[Subject(typeof(DisplayEquivalentAttribute))]\ninternal class when_displaying_an_enum_with_equivalent_text\n    {\n    It should_have_equivalent_text_when_the_attribute_is_present = () =&gt;\n        TestCases.CaseWithEquivalentText.DisplayEquivalent().ShouldEqual(\"Equivalent Text\");\n    It should_use_the_field_name_when_no_attribute_is_present = () =&gt;\n        TestCases.CaseWithoutEquivalentText.DisplayEquivalent()\n            .ShouldEqual(nameof(TestCases.CaseWithoutEquivalentText));\n    }\n\ninternal enum TestCases\n    {\n    [DisplayEquivalent(\"Equivalent Text\")] CaseWithEquivalentText,\n    CaseWithoutEquivalentText\n    }\n</code></pre>"},{"location":"Core/Finite%20State%20Machine/","title":"Finite State Machine (FSM)","text":"<p>This package provides a lightweight, composable finite state machine for orchestrating asynchronous workflows. It is designed to be simple enough for embedded or real\u2011time adjacent scenarios while remaining idiomatic for .NET applications.</p> <ul> <li>Interfaces: <code>IState</code>, <code>IFiniteStateMachine&lt;TState&gt;</code></li> <li>Implementation: <code>FiniteStateMachine&lt;TState&gt;</code></li> <li>Cross\u2011cutting: integrates cleanly with Diagnostics and Logging and Async Helpers</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#why-use-an-fsm","title":"Why use an FSM?","text":"<p>An FSM is a robust way to model systems that have a small number of modes of operation with well\u2011defined rules for moving between them. Typical examples include: - Device and protocol controllers (Idle \u2192 Connecting \u2192 Connected \u2192 Error \u2192 Reconnect) - UI or workflow wizards (Start \u2192 Collecting Input \u2192 Validating \u2192 Completed/Failed) - Stream/transport handlers (Listening \u2192 Handshaking \u2192 Streaming \u2192 Closing)</p> <p>Benefits - Deterministic behaviour: states explicitly define entry, run, and exit behaviour. - Clear separation of concerns: each state has a single responsibility. - Testability: transitions and hooks are easy to verify (see the included specifications). - Safe shutdown/transition: the framework cancels the running state and waits for it to exit before activating the next state. - Observability: transitions are published via <code>IObservable</code> so other components can react.</p> <p>Real\u2011time considerations - Bounded transitions: when <code>TransitionTo()</code> is called, the framework cancels the old state and only starts the new state after the old state\u2019s <code>RunAsync</code> completes and <code>OnExit</code> has run. This prevents overlap and race conditions. - No UI thread dependence: states run on background tasks (<code>Task.Run</code>) and use ContinueOnAnyThread semantics, avoiding message\u2011pump deadlocks. - Cooperative cancellation: each state\u2019s <code>RunAsync(CancellationToken)</code> cooperates to exit promptly on cancellation, allowing responsive hand\u2011overs.</p>"},{"location":"Core/Finite%20State%20Machine/#programming-model","title":"Programming model","text":"<p>Implement the <code>IState</code> interface for each state and drive transitions through <code>IFiniteStateMachine&lt;TState&gt;</code>.</p> <pre><code>public interface IState\n{\n    string DisplayName { get; }\n    void OnEnter();\n    void OnExit();\n    Task RunAsync(CancellationToken cancelOnExit);\n}\n</code></pre> <pre><code>public interface IFiniteStateMachine&lt;TState&gt; where TState : class, IState\n{\n    void TransitionTo(TState newState);\n    void StartStateMachine(TState initialState);\n    void StopStateMachine();\n\n    IObservable&lt;TState&gt; ObservableStates { get; }\n    TState? CurrentState { get; }\n}\n</code></pre> <p>Key runtime guarantees - Cancellation first: <code>TransitionTo(next)</code> cancels the current state\u2019s token before waiting. - Orderly exit/enter: after the current state\u2019s run task completes, <code>OnExit()</code> is called, then <code>OnEnter()</code> for the next state, then <code>RunAsync()</code> for the next state is started. - Blocking wait helper: <code>WaitUntil(predicate, timeout)</code> enables hosts/tests to synchronously wait until a condition on <code>CurrentState</code> is true (e.g., a specific state is activated). - Observable transitions: each activation is pushed to <code>ObservableStates</code>.</p>"},{"location":"Core/Finite%20State%20Machine/#minimal-example","title":"Minimal example","text":"<p>Below is a simplified controller with three states: Idle, Connecting, Connected. The Connecting state simulates work and then transitions to Connected; Connected waits until cancelled.</p> <pre><code>using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing TA.Utils.Core.Diagnostics;\nusing TA.Utils.Core.StateMachine;\n\npublic class IdleState : IState\n{\n    public string DisplayName =&gt; \"Idle\";\n    private readonly Action&lt;IState&gt; go;\n\n    public IdleState(Action&lt;IState&gt; transition)\n        =&gt; go = transition;\n\n    public void OnEnter() { /* noop */ }\n    public void OnExit()  { /* noop */ }\n\n    public Task RunAsync(CancellationToken cancel)\n    {\n        // Immediately move to Connecting\n        go(new ConnectingState(go));\n        return Task.CompletedTask;\n    }\n}\n\npublic class ConnectingState : IState\n{\n    public string DisplayName =&gt; \"Connecting\";\n    private readonly Action&lt;IState&gt; go;\n\n    public ConnectingState(Action&lt;IState&gt; transition) =&gt; go = transition;\n\n    public void OnEnter() { /* start timers, allocate resources */ }\n    public void OnExit()  { /* release temporary resources */ }\n\n    public async Task RunAsync(CancellationToken cancel)\n    {\n        try\n        {\n            // Simulate connection establishment\n            await Task.Delay(500, cancel).ConfigureAwait(false);\n            go(new ConnectedState());\n        }\n        catch (OperationCanceledException)\n        {\n            // Transition or stop was requested\n        }\n    }\n}\n\npublic class ConnectedState : IState\n{\n    public string DisplayName =&gt; \"Connected\";\n    public void OnEnter() { /* mark online */ }\n    public void OnExit()  { /* mark offline */ }\n\n    public async Task RunAsync(CancellationToken cancel)\n    {\n        // Run until cancelled by a transition or StopStateMachine()\n        try\n        {\n            while (!cancel.IsCancellationRequested)\n                await Task.Delay(100, cancel).ConfigureAwait(false);\n        }\n        catch (OperationCanceledException) { }\n    }\n}\n\n// Host\nvar log = new DegenerateLoggerService();\nvar fsm = new FiniteStateMachine&lt;IState&gt;(log);\n\n// Helper to allow states to request transitions without holding fsm directly.\nvoid Go(IState next) =&gt; fsm.TransitionTo(next);\n\nvar idle = new IdleState(Go);\nfsm.StartStateMachine(idle);\n</code></pre> <p>Notes - States can trigger transitions by holding an <code>Action&lt;IState&gt;</code> (or a reference to the FSM) passed via constructor DI. - Keep <code>OnEnter</code>/<code>OnExit</code> fast; perform long work inside <code>RunAsync</code>. - Always observe the <code>cancelOnExit</code> token and exit promptly on cancellation.</p>"},{"location":"Core/Finite%20State%20Machine/#observing-transitions","title":"Observing transitions","text":"<p>Other components can subscribe to state activations.</p> <pre><code>var subscription = fsm.ObservableStates.Subscribe(s =&gt;\n{\n    Console.WriteLine($\"Now in state: {s.DisplayName}\");\n});\n</code></pre> <p>In tests or synchronous orchestration, you can wait for a transition to complete using the blocking helper:</p> <pre><code>fsm.TransitionTo(new ConnectedState());\nfsm.WaitUntil(s =&gt; s != null &amp;&amp; s.DisplayName == \"Connected\", TimeSpan.FromSeconds(2));\n</code></pre>"},{"location":"Core/Finite%20State%20Machine/#synchronisation-helpers","title":"Synchronisation helpers","text":"<ul> <li>Concrete class: <code>FiniteStateMachine&lt;TState&gt;</code> exposes <code>WaitUntil(predicate, timeout)</code> and <code>WaitUntil(expected, timeout)</code> for blocking waits in tests or host code.</li> <li>Interface extension: for general <code>IFiniteStateMachine&lt;TState&gt;</code> usage (e.g., when working against the abstraction), use the provided extension methods in <code>TA.Utils.Core.StateMachine.FiniteStateMachineExtensions</code>:</li> </ul> <pre><code>IFiniteStateMachine&lt;IState&gt; fsm = new FiniteStateMachine&lt;IState&gt;(log);\nfsm.StartStateMachine(new IdleState(Go));\n// Extension method: blocks until Connected becomes current or the timeout elapses\nfsm.WaitUntil(s =&gt; s != null &amp;&amp; s.DisplayName == \"Connected\", TimeSpan.FromSeconds(2));\n</code></pre> <p>Notes - These helpers block the calling thread and are not suitable for UI threads. - Prefer async/reactive orchestration in production code; use blocking waits primarily in tests or simple host loops.</p>"},{"location":"Core/Finite%20State%20Machine/#error-handling-and-logging","title":"Error handling and logging","text":"<ul> <li>Exceptions in <code>RunAsync</code> should generally be caught inside the state and handled by transitioning to an error/recovery state.</li> <li>Exceptions in <code>OnExit</code> are caught by the FSM and logged, to avoid derailing the transition.</li> <li>Use Diagnostics and Logging to attach per\u2011state context (e.g., logger name, correlation ids).</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#timeouts-timers-and-external-events","title":"Timeouts, timers, and external events","text":"<ul> <li>Use <code>Task.WhenAny</code>, <code>Task.Delay(timeout, cancel)</code> or external event sources to decide when to transition.</li> <li>For periodic work, loop inside <code>RunAsync</code> with <code>await Task.Delay(...)</code> observing <code>cancelOnExit</code>.</li> <li>For external events (I/O, message bus), subscribe in <code>OnEnter</code> and unsubscribe in <code>OnExit</code>.</li> </ul> <p>Example: transition on timeout or signal, whichever comes first.</p> <pre><code>public class WaitingForSignal : IState\n{\n    public string DisplayName =&gt; \"WaitingForSignal\";\n    private readonly Action&lt;IState&gt; go;\n    private readonly TaskCompletionSource&lt;bool&gt; signal = new();\n\n    public WaitingForSignal(Action&lt;IState&gt; transition) =&gt; go = transition;\n    public void OnEnter() { /* wire external event =&gt; signal.TrySetResult(true) */ }\n    public void OnExit()  { /* unwire */ }\n\n    public async Task RunAsync(CancellationToken cancel)\n    {\n        var timeout = Task.Delay(TimeSpan.FromSeconds(2), cancel);\n        var completed = await Task.WhenAny(signal.Task, timeout).ConfigureAwait(false);\n        if (completed == signal.Task) go(new ConnectedState());\n        else go(new IdleState(go));\n    }\n}\n</code></pre>"},{"location":"Core/Finite%20State%20Machine/#best-practices","title":"Best practices","text":"<ul> <li>Keep state objects small, immutable where possible, and focused on one responsibility (SRP).</li> <li>Prefer composition: delegate specialized work (I/O, parsing) to collaborators injected into the state.</li> <li>Avoid blocking waits inside <code>RunAsync</code>\u2014always prefer async and honor cancellation.</li> <li>Design explicit Error/Recovering states rather than mixing error handling into every state.</li> <li>Publish enough metadata via logging to trace complex sequences (see Diagnostics and Logging and correlation guidance).</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#api-reference-summary","title":"API reference (summary)","text":"<ul> <li><code>IState</code></li> <li><code>DisplayName</code> \u2013 human\u2011readable identifier for diagnostics/UI</li> <li><code>OnEnter()</code> \u2013 called after previous state exits, before <code>RunAsync</code></li> <li><code>OnExit()</code> \u2013 called during transition out, after <code>RunAsync</code> completes</li> <li><code>RunAsync(CancellationToken)</code> \u2013 the main loop/logic; must observe cancellation</li> <li><code>IFiniteStateMachine&lt;TState&gt;</code></li> <li><code>StartStateMachine(TState initial)</code> \u2013 activates the initial state</li> <li><code>TransitionTo(TState next)</code> \u2013 cancels current state, waits, then activates <code>next</code></li> <li><code>StopStateMachine()</code> \u2013 cancels and exits, completes the observable, resets to inactive</li> <li><code>ObservableStates</code> \u2013 <code>IObservable&lt;TState&gt;</code> emitting each activated state</li> <li><code>CurrentState</code> \u2013 currently active state or null when stopped</li> </ul>"},{"location":"Core/Finite%20State%20Machine/#see-also","title":"See also","text":"<ul> <li>Async Helpers \u2013 avoiding context capture and UI deadlocks</li> <li>Diagnostics and Logging \u2013 adding semantic logging to states and transitions</li> <li>Versioning \u2013 how the repository versions assemblies and packages</li> </ul>"},{"location":"Core/Math%20Extensions/","title":"Math extensions","text":"<p>Utility methods for simple mathematical operations not provided by the BCL.</p>"},{"location":"Core/Math%20Extensions/#clipminimum-maximum","title":"Clip(minimum, maximum) <p>Constrains a comparable value to a closed interval [minimum, maximum]. Works with any <code>T : IComparable</code>.</p> <pre><code>5.2.Clip(0.0, 5.0);   // 5.0\n(-1).Clip(0, 10);      // 0\n'c'.Clip('a', 'b');    // 'b'\n</code></pre> <p>Notes - If <code>input &gt; maximum</code>, returns <code>maximum</code>; if <code>input &lt; minimum</code>, returns <code>minimum</code>; otherwise returns <code>input</code>. - For reference types that implement <code>IComparable</code>, semantics follow the type\u2019s comparison implementation.</p>","text":""},{"location":"Core/Maybe/","title":"<code>Maybe&lt;T&gt;</code>","text":"<p>One of the most insidious bug producers in .NET code is the null value. Do you return <code>null</code> to mean \"no value\"? What's the caller supposed to do with that? Did you mean there was an error? Did you mean there wasn't an error but you can't give an answer? Did you mean the answer was empty? Or did someone just forget to initialize the variable?</p> <p>I wrote this class long before Microsoft came up with their oddly-named nullable reference types feature, and I'm not a fan of Microsoft's solution to the Null Reference problem. I think their Nullable Reference Types [sic] are clumsy and make the code look ugly and noisy. They couldn't even get the name right - reference types were always nullable! Perhaps I'm biased because this is the way I chose to solve that problem, but I still prefer to use <code>Maybe&lt;T&gt;</code> to clearly communicate my intent to my users.</p> <p>The ambiguity around \"error\" vs. \"no value\" is why we created <code>Maybe&lt;T&gt;</code>.</p> <p><code>Maybe&lt;T&gt;</code> is a type that either has a value, or doesn't, but it is never null. The idea is that by using a <code>Maybe&lt;T&gt;</code> you clearly communicate your intentions to the caller. By returning <code>Maybe&lt;T&gt;</code> you nail down the ambiguity: \"there might not be a value and you have to check\".</p> <p>Strictly, a <code>Maybe&lt;T&gt;</code> is an <code>IEnumerable&lt;T&gt;</code> which is either empty (no value) or has exactly one element. Because it is <code>IEnumerable</code> you can use certain LINQ operators:</p> <ul> <li><code>maybe.Any()</code> will be true if there is a value.</li> <li><code>maybe.Single()</code> gets you the value.</li> <li><code>maybe.SingleOrDefault()</code> gets you the value or <code>null</code>, if you really wanted a null.</li> </ul> <p>Creating a maybe can be done by:</p> <ul> <li><code>object.AsMaybe();</code> - wrap a non-null object.</li> <li><code>Maybe&lt;int&gt;.From(7);</code> - works with value types, and also safe for null references.</li> <li><code>Maybe&lt;T&gt;.Empty</code> - a maybe without a value.</li> </ul> <p><code>Maybe&lt;T&gt;</code> has a <code>ToString()</code> method so you can write it to a stream or use in a string interpolation, and you will get the serialized value or \"<code>{no value}</code>\".</p> <p>Try returning a <code>Maybe&lt;T&gt;</code> whenever you have a situation wehere there may be no value, instead of <code>null</code>. You may find that your bug count tends to diminish.</p>"},{"location":"Core/Octet/","title":"Octet","text":"<p>An <code>Octet</code> is an immutable type that represents 8 bits, or a byte and provides bit-manipulation operators.</p> <p>In most cases, <code>Octet</code> can be directly used in place of a <code>byte</code> as there are implicit conversions to and from a <code>byte</code>. There are also explicit conversions to and from <code>int</code>. The latter is explicit because there is potentially data loss, so use with care.</p> <p>Note that conversion from <code>uint</code> has been deprecated because <code>uint</code> is not CLS Compliant, which can cause issues with other languages.</p> <p>In an <code>Octet</code>, each bit position is directly addressable as an array element. You can access <code>octet[0]</code> through <code>octet[7]</code> to read bit values.</p> <p>You can set a bit with <code>octet.WithBitSet(n)</code>. You can clear a bit with <code>octet.WithBitClear(n)</code>.</p> <p>Remember <code>Octet</code> is immutable so this gives you a new <code>Octet</code> and leaves the original unchanged.</p> <p>You can perform logical bitwise operations using the <code>&amp;</code> anf <code>|</code> operators. You can test octets for equality and compare them using <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>\\&lt;</code>, etc.</p>"},{"location":"Core/Property%20Binding/","title":"Property Binding Utilities","text":"<p>The property binding helpers enable you to populate plain C# objects from simple key\u2013value data, such as INI\u2011style text files, configuration dumps, or instrument logs. You describe how fields map to properties using a small attribute, and a binder performs type conversion and assignment for you.</p> <p>Components - Data source: a sequence of <code>KeyValueDataRecord</code> instances - Reader: <code>KeyValueReader</code> turns a text stream into <code>KeyValueDataRecord</code> items - Attribute: <code>DataKeyAttribute</code> decorates properties with the key name and an optional sequence - Binder: <code>PropertyBinder</code> maps records to properties, including collections</p> <p>Typical use cases - Importing device or test logs into typed DTOs - Parsing simple configuration files for applications and utilities - Converting textual dumps into strongly typed objects for validation and processing</p>"},{"location":"Core/Property%20Binding/#keyvalue-text-format","title":"Key\u2013value text format","text":"<ul> <li>One pair per line, with a delimiter between key and value. Default delimiters: <code>:</code> <code>=</code> <code>#</code>.</li> <li>Lines beginning with a comment character are ignored. Default comment openers: <code>#</code>.</li> <li>Whitespace around keys and values is trimmed.</li> <li>Lines that cannot be parsed into a pair are skipped.</li> </ul> <p>You can override delimiters and comment characters when constructing <code>KeyValueReader</code>.</p> <pre><code>using var stream = File.OpenRead(path);\nusing var reader = new KeyValueReader(stream, delimiters: new[] { ':', '=' }, commentChars: new[] { '#', ';' });\nIEnumerable&lt;KeyValueDataRecord&gt; records = reader.KeyValueDataRecords();\n</code></pre>"},{"location":"Core/Property%20Binding/#decorating-a-target-type","title":"Decorating a target type","text":"<p>Annotate properties with <code>DataKeyAttribute</code> when the key name differs from the property name, or when you want to supply multiple fallbacks and ordering using <code>Sequence</code>.</p> <pre><code>public sealed class DeviceInfo\n{\n    // Matches either the explicit key \"model\" or, if omitted, the property name \"Model\" (case\u2011insensitive)\n    [DataKey(\"model\")]\n    public string Model { get; set; }\n\n    // Multiple fallbacks with ordered preference\n    [DataKey(\"serial\", Sequence = 0)]\n    [DataKey(\"sn\",     Sequence = 1)]\n    public string SerialNumber { get; set; }\n\n    // Collection properties must use DataKeyAttribute; all matching values are added\n    [DataKey(\"alias\")]\n    [DataKey(\"alt_name\")] // both keys, accumulated\n    public List&lt;string&gt; Aliases { get; set; }\n}\n</code></pre> <p>Rules - If one or more <code>DataKeyAttribute</code> decorations are present, their <code>Keyword</code> values are used in ascending <code>Sequence</code> order to search for matching records. - If no attribute is present, the property\u2019s name is used as the key (case\u2011insensitive). - For simple properties, the first successfully converted value is assigned. - For collection properties that implement <code>IList</code> or <code>IList&lt;T&gt;</code>, all matching values across all specified keys are converted and added to the collection.</p>"},{"location":"Core/Property%20Binding/#binding","title":"Binding","text":"<p>Create a binder and produce an instance of your DTO from a sequence of records. The binder logs diagnostic information via the repository\u2019s logging abstraction.</p> <pre><code>var binder = new PropertyBinder();\nDeviceInfo dto = binder.BindProperties&lt;DeviceInfo&gt;(records);\n</code></pre> <p>Behaviour when keys are missing or conversion fails - If no matching record is found for a property, the property is left at its default value. - If conversion fails for a record, the binder logs an error and leaves the property unchanged. Other properties continue to bind.</p>"},{"location":"Core/Property%20Binding/#type-conversion","title":"Type conversion","text":"<p>The binder uses <code>TypeDescriptor</code> to convert strings to the destination type using <code>InvariantCulture</code>. Special cases: - Strings are trimmed and returned as\u2011is. - <code>Nullable&lt;T&gt;</code> is supported; the underlying type is used for conversion. - For custom types, provide a <code>TypeConverter</code> or bind as <code>string</code> and convert later.</p> <p>Examples</p> <pre><code>public sealed class Reading\n{\n    public string Id { get; set; }\n    public int Count { get; set; }              // \"42\" \u2192 42\n    public double TemperatureC { get; set; }    // \"23.5\" \u2192 23.5 (invariant culture)\n    public DateTime Timestamp { get; set; }     // \"2025-09-23T10:00:00Z\" \u2192 DateTime\n    public int? OptionalLevel { get; set; }     // supports Nullable&lt;int&gt;\n}\n</code></pre> <pre><code>var text = @\"\n# Device log\nmodel = ZX-200\nserial = A1B2C3\nalias = \"\"Alpha Unit\"\"\nalt_name = \"\"Primary\"\"\nCount: 42\nTemperatureC: 23.5\nTimestamp: 2025-09-23T10:00:00Z\n\";\nusing var ms = new MemoryStream(Encoding.UTF8.GetBytes(text));\nusing var reader = new KeyValueReader(ms);\nvar records = reader.KeyValueDataRecords();\n\nvar binder = new PropertyBinder();\nvar info = binder.BindProperties&lt;DeviceInfo&gt;(records);\nvar reading = binder.BindProperties&lt;Reading&gt;(records);\n</code></pre>"},{"location":"Core/Property%20Binding/#collections","title":"Collections","text":"<p>When a destination property implements <code>IList</code> or <code>IList&lt;T&gt;</code>, property binding will: - Require <code>DataKeyAttribute</code> on the property to specify which keys to aggregate. - Convert all matching values across all listed keys. - Instantiate the target collection type if it is a concrete <code>IList</code> implementation; otherwise, create a <code>List&lt;T&gt;</code> at runtime and assign it to the property.</p> <pre><code>public sealed class Tags\n{\n    [DataKey(\"tag\")]\n    [DataKey(\"label\", Sequence = 1)]\n    public IList&lt;string&gt; Values { get; set; }\n}\n</code></pre> <p>Input like:</p> <pre><code>label = good\nlabel = fast\ntag = cheap\n</code></pre> <p>binds to <code>Values = [\"good\", \"fast\", \"cheap\"]</code> (order follows appearance in the data).</p>"},{"location":"Core/Property%20Binding/#case-sensitivity-and-ordering","title":"Case sensitivity and ordering","text":"<ul> <li>Key lookup is case\u2011insensitive.</li> <li>When multiple <code>DataKeyAttribute</code>s decorate a property, they are processed in ascending <code>Sequence</code> order.</li> <li>For simple properties, the first found value wins. For collections, all matching values are accumulated in the order encountered.</li> </ul>"},{"location":"Core/Property%20Binding/#error-handling-and-logging","title":"Error handling and logging","text":"<ul> <li>Conversion failures raise an <code>InvalidOperationException</code> internally and are logged through the <code>ILog</code> abstraction. Binding then proceeds to the next property.</li> <li>For collections, if the collection cannot be instantiated, the binder logs a warning and skips population.</li> </ul>"},{"location":"Core/Property%20Binding/#practical-tips","title":"Practical tips","text":"<ul> <li>Prefer explicit <code>DataKeyAttribute</code> on public DTOs, even when keys match property names, to avoid hidden coupling and to document intent.</li> <li>Keep DTOs simple and immutable where practical; for immutable records, bind into a mutable intermediate and project.</li> <li>If you need culture\u2011specific number formats, normalise input to invariant format at source or add a preprocessing pass.</li> <li>For complex transformations, bind strings first and convert with domain\u2011specific logic afterwards.</li> </ul>"},{"location":"Core/Property%20Binding/#reference","title":"Reference","text":"<ul> <li><code>KeyValueReader</code> \u2014 parse a text stream into <code>KeyValueDataRecord</code> items (configurable delimiters and comments)</li> <li><code>KeyValueDataRecord</code> \u2014 holds a <code>Key</code> and a <code>Value</code> string</li> <li><code>DataKeyAttribute</code> \u2014 decorate properties with a <code>Keyword</code> and optional <code>Sequence</code></li> <li><code>PropertyBinder</code></li> <li><code>TOut BindProperties&lt;TOut&gt;(IEnumerable&lt;KeyValueDataRecord&gt;) where TOut : new()</code></li> </ul> <p>See also - Diagnostics and Logging - Async Helpers - Finite State Machine</p>"},{"location":"Core/SemanticVersion/","title":"SemanticVersion","text":"<p>Encapsulates parsing, validation, display formatting, equality, and sorting of SemVer strings. Pre-release and build metadata are handled per SemVer 2.0.0 rules.</p> <ul> <li>Parse: <code>new SemanticVersion(\"1.0.0-alpha.1+meta\")</code></li> <li>Validate: <code>SemanticVersion.IsValid(\"1.0.0\")</code></li> <li>Compare/sort: compares major/minor/patch; pre-releases sort before releases; numeric identifiers sort numerically.</li> </ul> <p>Examples (from specifications): - <code>new(\"1.0.1-alpha.9\") &lt; new(\"1.0.1-alpha.10\")</code> - Build metadata is ignored for equality.</p>"},{"location":"Core/String%20Extensions/","title":"String extensions","text":"<p>Helpers for common string manipulation tasks: filtering characters, extracting head/tail segments, trimming from either end, and rendering strings as hexadecimal. All methods are extension methods on <code>string</code> and return new strings (do not mutate the original).</p> <p>See also - ASCII Mnemonic Expansion \u2014 show control characters as mnemonics (e.g., \\&lt;CR&gt;)</p>"},{"location":"Core/String%20Extensions/#clean-remove-unwanted-characters","title":"Clean: remove unwanted characters","text":"<p>Removes all characters that appear in the supplied <code>clean</code> set and preserves the rest.</p> <pre><code>var source = \"A-B_C\";\nvar cleaned = source.Clean(\"-_\");   // \"ABC\"\n</code></pre> <p>Notes - If <code>source</code> is <code>null</code> or empty, returns <code>string.Empty</code>. - If <code>clean</code> is <code>null</code> or empty, returns <code>source</code> unchanged. - Complexity is O(n \u00d7 m) where n is the source length and m is <code>clean.Length</code>. A HashSet can be faster when <code>clean</code> is very large, but for typical small sets the simple approach is competitive.</p>"},{"location":"Core/String%20Extensions/#keep-keep-only-wanted-characters","title":"Keep: keep only wanted characters","text":"<p>The inverse of Clean. Keeps only characters that appear in the supplied <code>keep</code> set and removes all others.</p> <pre><code>var digits = \"a1b2c3\".Keep(\"0123456789\"); // \"123\"\n</code></pre> <p>Notes - If <code>source</code> is <code>null</code> or empty, returns <code>string.Empty</code>.</p>"},{"location":"Core/String%20Extensions/#head-take-the-first-n-characters","title":"Head: take the first N characters","text":"<p>Returns the first <code>length</code> characters of the string.</p> <pre><code>\"abcdef\".Head(3);     // \"abc\"\n</code></pre> <p>Exceptions - <code>ArgumentNullException</code> if <code>source</code> is <code>null</code>. - <code>ArgumentOutOfRangeException</code> if <code>length</code> &lt; 0 or <code>length</code> &gt; <code>source.Length</code>.</p>"},{"location":"Core/String%20Extensions/#tail-take-the-last-n-characters","title":"Tail: take the last N characters","text":"<p>Returns the last <code>length</code> characters of the string.</p> <pre><code>\"abcdef\".Tail(2);     // \"ef\"\n</code></pre> <p>Exceptions - <code>ArgumentOutOfRangeException</code> if <code>length</code> &gt; <code>source.Length</code>.</p>"},{"location":"Core/String%20Extensions/#removehead-drop-n-characters-from-the-start","title":"RemoveHead: drop N characters from the start","text":"<p>Removes <code>length</code> characters from the start; returns the remainder.</p> <pre><code>\"abcdef\".RemoveHead(2);   // \"cdef\"\n</code></pre> <p>Notes - If <code>length</code> &lt; 1, returns <code>source</code> unchanged. - If <code>length</code> exceeds the source length, <code>Tail()</code> will throw; ensure the value is within range if you do not want an exception.</p>"},{"location":"Core/String%20Extensions/#removetail-drop-n-characters-from-the-end","title":"RemoveTail: drop N characters from the end","text":"<p>Removes <code>length</code> characters from the end; returns the remainder.</p> <pre><code>\"abcdef\".RemoveTail(2);   // \"abcd\"\n</code></pre> <p>Notes - If <code>length</code> &lt; 1, returns <code>source</code> unchanged. - If <code>length</code> exceeds the source length, <code>Head()</code> will throw; ensure the value is within range if you do not want an exception.</p>"},{"location":"Core/String%20Extensions/#tohex-visualise-character-codes","title":"ToHex: visualise character codes","text":"<p>Renders each character\u2019s numeric value in lower\u2011case hexadecimal, surrounded by braces.</p> <pre><code>\"Az\".ToHex();   // \"{41, 7a}\"\n</code></pre> <p>Notes - Useful for diagnostics and debugger output when inspecting non\u2011printable characters or code points.</p>"},{"location":"Core/String%20Extensions/#read-lines-helpers-related","title":"Read lines helpers (related)","text":"<p>There is a companion set of helpers for splitting a string or stream into lines without allocating the entire array up front.</p> <pre><code>// From a string\nforeach (var line in bigText.GetLines()) { /* ... */ }\n\n// From a stream\nawait using var fs = File.OpenRead(path);\nforeach (var line in fs.GetLines()) { /* ... */ }\n</code></pre> <p>Rules - A line ends at CR (0x0D), LF (0x0A), CRLF, <code>Environment.NewLine</code>, or end\u2011of\u2011input; terminators are not included in the returned lines.</p> <p>See also - ASCII Mnemonic Expansion</p>"},{"location":"Logging/NLog%20Adapter/","title":"NLog adapter","text":"<p>An implementation of the logging abstraction (<code>ILog</code>/<code>IFluentLogBuilder</code>) that targets NLog as the back\u2011end. It maps fluent builder calls to NLog\u2019s <code>LogEventInfo</code>, supports semantic properties, and integrates cleanly with NLog targets including Seq.</p> <ul> <li>Package: TA.Utils.Logging.Nlog</li> <li>Classes: <code>LoggingService</code>, <code>LogBuilder</code>, <code>LogServiceOptions</code></li> </ul>"},{"location":"Logging/NLog%20Adapter/#quick-start","title":"Quick start","text":"<pre><code>using TA.Utils.Logging.NLog;\n\nvar options = LogServiceOptions.DefaultOptions\n    .UseVerbosity()\n    .CustomSeverityPropertyName(\"CustomLevel\");\n\nILog log = new LoggingService(options)\n    .WithAmbientProperty(\"CorrelationId\", Guid.NewGuid());\n\nlog.Info().Message(\"Hello {who}\").Property(\"who\", \"world\").Write();\nlog.Level(\"Important\").Message(\"This is important\").Write();\n</code></pre>"},{"location":"Logging/NLog%20Adapter/#verbosity-and-custom-levels","title":"Verbosity and custom levels","text":"<ul> <li>UseVerbosity(propertyName = \"verbosity\")</li> <li>Adds a numeric verbosity property to each entry when you pass the number to the severity method (e.g., <code>Info(2)</code>).</li> <li>CustomSeverityPropertyName(name = \"CustomLevel\")</li> <li>The custom severity property used when you call <code>log.Level(\"Name\")</code>.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#seq-target-mapping-example","title":"Seq target mapping example","text":"<p>To use custom levels with Seq, configure the Seq target to take its level from the custom property when present:</p> <pre><code>&lt;target xsi:type=\"Seq\" name=\"seq\"\n        serverUrl=\"http://your-server-url:5341\"\n        apiKey=\"your-seq-api-key\"\n        seqLevel=\"${event-properties:CustomLevel:whenEmpty=${level}}\" /&gt;\n</code></pre>"},{"location":"Logging/NLog%20Adapter/#logger-names-and-ambient-properties","title":"Logger names and ambient properties","text":"<ul> <li><code>WithName(\"Source\")</code> sets the logger name, which NLog can use for routing and filtering (e.g., <code>${logger}</code> in layouts).</li> <li><code>WithAmbientProperty(\"name\", value)</code> adds a property to all subsequent entries; useful for correlation IDs, component, tenant, etc.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#message-templates-and-properties","title":"Message templates and properties","text":"<ul> <li>Use either indexed placeholders (<code>{0}</code>) or named placeholders (<code>{name}</code>); named placeholders are recommended for semantic logging.</li> <li>Attach additional properties explicitly via <code>.Property(\"name\", value)</code> or <code>.Properties(dict)</code>.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#shutdown","title":"Shutdown","text":"<ul> <li>Call <code>log.Shutdown()</code> or rely on NLog\u2019s <code>AutoShutdown = true</code> set by the adapter type initialiser.</li> </ul>"},{"location":"Logging/NLog%20Adapter/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If a property name collides, the adapter auto\u2011deconflicts by suffixing a number (e.g., <code>property</code>, <code>property2</code>).</li> <li>Ensure <code>IsEnabled(Level)</code> is true for the chosen level; otherwise <code>.Write()</code> is a no\u2011op.</li> </ul> <p>See also - Diagnostics and Logging - Console logger (Diagnostics) - ASCII Mnemonic Expansion</p>"},{"location":"Samples/Traffic%20Light%20FSM%20Demo%20Overview/","title":"Traffic Light FSM Demo Overview","text":"<p>Purpose - Demonstrate the use of the TA.Utils.Core FiniteStateMachine with a realistic, visual example. - Showcase clean separation between state behaviour (IState), triggering actions (ITrafficLightActions), and orchestration (IApproachSequencer), following SOLID and MVVM. - Provide a deterministic, testable simulation using .NET 8 TimeProvider. <p>What the demo simulates - An n\u2011way controlled area with one traffic light (approach) per entry. - Each traffic light runs an independent FSM modelling phases as states: InactiveRed \u2192 RedAmber \u2192 Green \u2192 Amber \u2192 ClearingRed \u2192 InactiveRed. Fault is modelled as a flashing Amber state with no runtime exit. - A sequencer that selects which approach is active using a round\u2011robin policy (single active approach in the initial implementation). - Traffic flow via arrivals and departures per approach with configurable rates.</p> <p>How it works (high level) - On Start, the app starts the arrival and departure simulations, starts the sequencer, then starts each approach\u2019s FSM after a random startup delay (up to 10 s). The sequencer waits until all lights report InactiveRed before sequencing. - The sequencer activates one approach at a time by sending SetActiveApproach(config), which supplies per\u2011activation timings (ActiveTime, TransitionTime, ClearingTime). The light runs its FSM to completion and returns to InactiveRed, signalling the sequencer to select the next approach. - While an approach is in Green, the sequencer may resend SetActiveApproach(config) to reset and adjust the dwell time from the moment of receipt. - Stop sends StopTraffic to all approaches and waits for all to reach InactiveRed; simulations stop when the sequencer stops. Reset performs a full restart to recover from Fault.</p> <p>UI overview - Approach tiles show a visual traffic light, current state name, and time remaining. - A full\u2011width chart plots queue length over time, one coloured line per approach. - Controls:   - Start/Stop/Reset (IRelayCommand\u2011bound, auto\u2011disabled while executing)   - Number of approaches (editable only while stopped)   - Timing and simulation inputs: ActiveTime, TransitionTime, ClearingTime; arrival mean (1\u2013300 s); departure interval (1.0\u201310.0 s) - Telemetry formatting uses fixed width with signed values per house style.</p> <p>Traffic model - Arrivals: stochastic process with configurable mean inter\u2011arrival time (recommended exponential distribution), one RNG stream per approach. - Departures (active approach): deterministic interval; departures are eligible during Green and the first half of Amber (TransitionTime/2) only. - Queue length updates on every arrival and departure; the chart updates in real time with efficient sampling.</p> <p>Design principles highlighted - Interface Segregation (ITrafficLightState vs ITrafficLightActions) - Dependency Injection (Ninject CompositionRoot) - Determinism and testability (TimeProvider\u2011driven timers; MSpec BDD tests) - Clear orchestration vs behaviour separation (Sequencer vs Light FSM)</p> <p>What to explore next - Alternative sequencing strategies (e.g., favour longest queue, sensor\u2011driven) - Multi\u2011active compatibility groups - Fault detection and reporting - Persistence of configurations and session replay</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/","title":"Traffic Light Simulation \u2014 Final Specification","text":"<ol> <li>This sample simulates an n\u2011way traffic light controlled area. The user may select how many approaches to simulate and a traffic light will exist for each approach. Each light is modelled as a finite state machine, with one instance per light.</li> </ol>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#definitions","title":"Definitions","text":"<p>Traffic : Something, typically a vehicle or person, that wishes to transit a controlled area.</p> <p>Controlled Area : The area controlled by a set of traffic lights, though which traffic may transit. Typically a section of road or a road interchange, but can also be other areas such as pedestrian walkways, one\u2011way streets, tunnels, staircases or any area in which the flow of traffic must be controlled.</p> <p>Traffic Light : A visual indication to traffic that it may or may not enter a controlled area. A traffic light is an independent modular unit with a fixed phase sequence of colours. When triggered by the approach sequencer, the light becomes an active approach and begins transitioning through its phase sequence, which is modelled as a finite state machine. Upon completion of the sequence, the light signals the approach sequencer that it has completed its cycle and is back at the InactiveRed phase.</p> <p>Phase : A distinct state of a traffic light that can be mapped to a colour display. The possible colour configurations are: Red, Red+Amber, Green, Amber.</p> <p>Approach : The location where traffic may enter the controlled area by passing a traffic light. There will be a traffic light at each approach.</p> <p>Active Approach : Any approach that is currently allowing traffic to transit the controlled area.</p> <p>Inactive Approach : An approach that is not allowing traffic to transit the controlled area. An inactive approach shall display a red light.</p> <p>Approach Sequencer : A service that monitors the state of each approach and decides which approach(es) are to become active. The application shall be architected to support multiple active approaches; however, the initial sequencer implementation shall allow exactly one active approach at a time using a round\u2011robin strategy. More sophisticated strategies (e.g., favouring the longest queue or sensor\u2011driven activation) may be introduced later.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#state-machine-design","title":"State Machine Design","text":""},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#traffic-light","title":"Traffic Light","text":"<p>There shall exist a set of custom states; ITrafficLightState inherits IState, and an abstract class TrafficLightStateBase implements ITrafficLightState. The state machine instance for each light will be created as <code>FiniteStateMachine&lt;ITrafficLightState&gt;</code>. Triggering actions are separated into a dedicated interface ITrafficLightActions to follow the Interface Segregation Principle (ISP).</p> <p>The light exposes the following triggering actions via ITrafficLightActions (states do not implement these): - SetActiveApproach(ApproachActivationConfig config) in the InactiveRed state starts the phase sequence using config for all phase timings of the activation. When received in the Green state, it replaces the current activation configuration with config and resets the Green phase timer (ActiveTime) from the moment of receipt, allowing the sequencer to extend or reduce the green dwell by issuing additional SetActiveApproach triggers while in Green. It is ignored in all other states. - FaultDetected \u2014 causes immediate transition to a per\u2011light Fault state (flashing Amber) to indicate a hardware or critical error affecting that approach. - StopTraffic \u2014 triggers an orderly transition from the current phase towards InactiveRed.</p> <p>StopTraffic behaviour: - From any state except InactiveRed and ClearingRed, transition immediately to Amber, which will then transition to ClearingRed and then InactiveRed by normal timing. - In InactiveRed and ClearingRed, StopTraffic has no effect (ignored). - From Fault, there is no transition; recovery requires a complete system restart.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#approach-sequencer","title":"Approach Sequencer","text":"<p>The Approach Sequencer must be pluggable. Different sequencing strategies shall be possible simply by substituting a different sequencer implementation. There will be an IApproachSequencer interface and an initial basic implementation SimpleRoundRobinApproachSequencer that allows one active approach and round\u2011robin scheduling.</p> <p>Upon start\u2011up, the sequencer shall await a signal from each approach that it is in the InactiveRed ready state and must receive the signal from every approach before any approach can become active.</p> <p>Sequencer\u2013light contract: - The sequencer subscribes to each light\u2019s ObservableStates to detect InactiveRed (completion) and Green (for potential dwell adjustments). - Initial strategy: strict round\u2011robin across configured approaches; start from index 0 on system start. - The sequencer may resend SetActiveApproach(config) while a light is in Green to extend or reduce dwell. It should not send SetActiveApproach in other phases. - The sequencer shall not select a light in Fault. - Recovery: Restart stops all FSMs, disposes subscriptions, reconstructs lights and sequencer, and starts from InactiveRed.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#configuration","title":"Configuration","text":""},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#activation-configuration-dto","title":"Activation Configuration DTO","text":"<p>The sequencer shall supply an immutable activation snapshot on each activation and any Green re\u2011arm:</p> <pre><code>public sealed record ApproachActivationConfig(\n    string ActivationId,\n    DateTimeOffset TimestampUtc,\n    TimeSpan ActiveTime,\n    TimeSpan TransitionTime,\n    TimeSpan ClearingTime\n);\n\npublic interface ITrafficLightActions\n{\n    void SetActiveApproach(ApproachActivationConfig config);\n    void StopTraffic();\n    void FaultDetected();\n}\n\npublic interface ITrafficLightState : IState { }\n</code></pre> <ul> <li>The light implements ITrafficLightState (for FSM participation) and ITrafficLightActions (for triggers) via its controller/aggregate, keeping state types focused on state behaviour.</li> </ul> <p>Configuration items and purpose:</p> Configuration Item Purpose Units ClearingTime The dwell time after a traffic light returns to red before the next approach can become active. seconds TransitionTime Time to remain at Amber or RedAmber. seconds ActiveTime The time for the approach to maintain a green light. seconds <p>Application points: - TransitionTime applies to RedAmber and Amber. - ActiveTime applies to Green. - ClearingTime applies to ClearingRed and is included in ApproachActivationConfig.</p> <p>Configuration for an approach is supplied as an immutable activation snapshot via SetActiveApproach(ApproachActivationConfig config). The light does not persist configuration; the effective timings for a cycle are those in the most recently received config for the current activation. When in Green, receipt of a new SetActiveApproach(config) replaces the current activation configuration and resets the Green timer from the moment of receipt; otherwise, new configuration takes effect on the next activation from InactiveRed. Validation of configuration values is performed by the sequencer.</p> <p>Validation and defaults: - ActiveTime default 15.0 s; allowed range 0.5\u2013120.0 s. - TransitionTime default 2.0 s; allowed range 0.5\u201310.0 s. - ClearingTime default 2.0 s; allowed range 0.5\u201310.0 s. - The sequencer shall reject configurations outside these ranges.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#phase-transitions","title":"Phase Transitions","text":"<p>The phases and their mapping to the colour display are:</p> Phase (state name) Colour Display InactiveRed Red RedAmber Red and Amber Green Green Amber Amber ClearingRed Red Fault flashing Amber at 2 Hz (50% duty) <p>When SetActiveApproach(config) is triggered in the InactiveRed state, this starts the light clocking through its phase sequence and sets the current activation configuration to config; when triggered in the Green state it replaces the current activation configuration with config and resets the Green phase timer (ActiveTime) from the moment of receipt. It is ignored in all other phase states. The phase transitions are as defined in the following diagram:</p> <pre><code>@startuml Traffic Light State Machine\nskinparam state {\n  BackgroundColor&lt;&lt;Active&gt;&gt; LightGreen\n}\n\nstate InactiveRed\nstate RedAmber\nstate Green &lt;&lt;Active&gt;&gt;\nstate Amber\nstate ClearingRed\nstate Fault\n\n' Fault displays flashing Amber at 2 Hz (50% duty)\n\n[*] --&gt; InactiveRed\n\n' Normal sequencing\nInactiveRed --&gt; RedAmber : SetActiveApproach\nRedAmber --&gt; Green : TransitionTime elapsed\nGreen --&gt; Amber : ActiveTime elapsed\nAmber --&gt; ClearingRed : TransitionTime elapsed\nClearingRed --&gt; InactiveRed : ClearingTime elapsed\n\n' StopTraffic handling (orderly stop)\nGreen --&gt; Amber : StopTraffic\nRedAmber --&gt; Amber : StopTraffic\n\n' SetActiveApproach while in Green resets the dwell timer\nGreen --&gt; Green : SetActiveApproach (reset ActiveTime)\n\n' Faults (per-light)\nInactiveRed --&gt; Fault : FaultDetected\nRedAmber --&gt; Fault : FaultDetected\nGreen --&gt; Fault : FaultDetected\nAmber --&gt; Fault : FaultDetected\n\n' No runtime exit from Fault (requires system restart)\n@enduml\n</code></pre> <p>Each state's OnEnter method initialises a phase timer with an appropriate value for that state, taken from the activation configuration. When the phase timer expires, it triggers transition to the next state. The exception to this is the InactiveRed state, which has no timeout and transitions only when triggered by the sequencer. Timers are implemented within each state's RunAsync(CancellationToken) using async delays.</p> <p>Each traffic light uses a finite state machine to control its transitions based on <code>TA.Utils.StateMachine.FiniteStateMachine&lt;ITrafficLightState&gt;</code>. All lights start InactiveRed and must remain so until they are triggered to become the active approach. An ApproachSequencer service will select one of the lights and send it the SetActiveApproach trigger. The light will then cycle through its state machine until it becomes InactiveRed again (after the ClearingRed dwell), after which the sequencer may select another light to become the active approach. Initially, a round\u2011robin sequencing strategy will be used but this must be extensible so that more advanced strategies can be added later.</p> <p>The sequencer should implement a timeout period, within which each approach must complete its sequence. If any light does not signal completion within the allowed time, an error condition is declared. Sequencing halts and operator intervention is required; behaviour on timeout does not trigger any automatic state changes in this version.</p> <p>Faults - Per\u2011light faults: FaultDetected transitions that light to Fault (flashing Amber). The sequencer shall not select a light in Fault as an active approach. - There is no runtime exit from Fault; recovery requires a complete system restart.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#application-architecture","title":"Application Architecture","text":""},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#general","title":"General","text":"<p>The application shall be a Windows MAUI cross\u2011platform app and shall work on Windows as the reference implementation, plus Android, at minimum.</p> <p>The app shall be developed test\u2011first using the MSpec BDD specification framework. Where possible, the Establish, Because and It members of each test shall be a single statement. The use of builders (especially in the Establish statement) and context classes should be used where this makes tests smaller and more readable. Time should be abstracted using .NET 8 TimeProvider so unit tests can run without real delays (use a controllable TimeProvider in tests).</p> <p>The app shall adhere to the SOLID Principles of object oriented design and there shall be a strong preference for clean, readable code over compactness or performance. Robert C. Martin's clean code principles shall be followed where practicable.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#ui-design-pattern","title":"UI Design Pattern","text":"<p>The UI shall use the MVVM pattern and minimise the use of code\u2011behind in views.</p> <p>The application shall prefer to use the PropertyChanged.SourceGenerator NuGet package to source\u2011generate all observable public properties in ViewModels, and optionally other model classes.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#composition-root-and-dependency-injection","title":"Composition Root and Dependency Injection","text":"<p>The app shall use Dependency Injection via the Ninject library and shall have a static CompositionRoot class that owns and configures the DI kernel and provides a method <code>TService Get&lt;TService&gt;()</code> that encapsulates the DI framework. Where possible, all object creation and lifetime management shall be delegated to the Dependency Injection framework. Where possible, objects should receive their dependencies via constructor injection.</p>"},{"location":"Samples/Traffic%20Light%20Simulation%20Design%20Specification/#uiux-for-the-sample","title":"UI/UX for the sample","text":"<ul> <li>Controls: Start, Stop, Reset; number of approaches selector (editable only while sequencing is stopped); editable ActiveTime, TransitionTime, ClearingTime per approach.</li> <li>Visuals: For each approach, render a traffic light with Red, Red+Amber, Green, Amber states and a flashing Amber for Fault.</li> <li>Telemetry/logging: Show current state name and time remaining in the current state for each approach; show recent transitions. Telemetry values shall use a fixed field width and always include a signed value as per house style.</li> </ul> <p>Simulation model and telemetry - Queue length per approach: Maintain and display a live queue length for each approach; update on each simulated arrival and departure event. - Traffic arrivals (per approach): Simulate arrivals using a stochastic process parameterised by the configured mean inter\u2011arrival time (seconds). UI range 1\u2013300 s, resolution 1 s. Recommended distribution: exponential with mean equal to the configured value. Changes in the UI take effect immediately. - Traffic departures (active approach only): Simulate departures at a configurable interval (seconds between departures). UI range 1.0\u201310.0 s, resolution 0.1 s. Departures are eligible while the approach is in Green and during the first half of the Amber phase (i.e., for TransitionTime/2 after entering Amber). No departures occur during RedAmber, ClearingRed, or InactiveRed. Changes in the UI take effect immediately. - Immediate effect of UI controls: All changes to simulation controls (arrival mean, departure interval, number of approaches, timings) shall immediately affect simulation behaviour; use .NET 8 TimeProvider to ensure deterministic, testable timing. - Queue length graph: Display a chart of queue length over time across all approaches. The chart shall be full window width and appear at the top of the window. Represent each approach as a distinct coloured line; update in real time with efficient sampling to avoid UI jank. - Time remaining display: For the current state, compute time remaining based on the state\u2019s scheduled expiry using TimeProvider and the active ApproachActivationConfig. Ensure the display updates at least 10 Hz for smoothness without excessive CPU usage. - Fault state rendering: In Fault, display a flashing Amber lamp at 2 Hz (50% duty); queue length updates continue to be displayed; arrivals should continue to be simulated, but departures do not occur while not active. - Accessibility: The state name is displayed and is unambiguous; no separate colour labels are required. Ensure sufficient contrast for the chart and lamp visuals.</p> <p>Control semantics - Start (IRelayCommand): Starts the arrival and departure simulations, starts the sequencer, then starts each approach\u2019s state machine after a random start\u2011up delay of up to 10 seconds per approach (using TimeProvider). The Start button binds to an IRelayCommand and is disabled while its action executes. The sequencer shall not begin selecting an active approach until it has observed every approach enter InactiveRed (i.e., it has seen each FSM start and reach ready state). - Stop (IRelayCommand): Causes the sequencer to send StopTraffic to all approaches, then wait until every approach has entered InactiveRed. Once the sequencer has fully stopped, the arrival and departure simulations shall also stop. The Stop button binds to an IRelayCommand and is disabled while its action executes. - Reset (IRelayCommand): Restarts the sequencer and all approaches to recover from a fault state (equivalent to stop, re\u2011initialise, and start as above). The Reset button binds to an IRelayCommand and is disabled while its action executes. Fault detection is not yet modelled and will be introduced in a future iteration. - Number of approaches: This value may be changed only while the sequencer is stopped. The UI shall disable or reject changes to this control while the system is operational. After a change, on the next Start, approaches are (re)created and the round\u2011robin sequencer restarts from index 0.</p>"}]}